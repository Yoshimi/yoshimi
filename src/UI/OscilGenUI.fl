# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cc}
comment {OscilgenUI.h} {not_in_source in_header
}

comment {OscilgenUI.cc} {in_source not_in_header
}

comment {Original ZynAddSubFX author Nasca Octavian Paul
Copyright (C) 2002-2005 Nasca Octavian Paul
Copyright 2009-2010, Alan Calvert
Copyright 2016-2020 Will Godfrey and others.

This file is part of yoshimi, which is free software: you can redistribute
it and/or modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.

yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
later) for more details.

You should have received a copy of the GNU General Public License along with
yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA.

This file is a derivative of the ZynAddSubFX original.

} {selected in_source in_header
}

decl {\#include "ResonanceUI.h"} {public local
}

decl {\#include <FL/Fl_Box.H>} {public local
}

decl {\#include <FL/Fl_Group.H>} {public local
}

decl {\#include <FL/Fl_Slider.H>} {public local
}

decl {\#include <cmath>} {private local
}

decl {\#include "UI/MiscGui.h"} {public local
}

decl {\#include "UI/WidgetPDial.h"} {public local
}

decl {\#include "UI/WidgetMWSlider.h"} {public local
}

decl {\#include "EnvelopeUI.h"} {public local
}

decl {\#include "LFOUI.h"} {public local
}

decl {\#include "FilterUI.h"} {public local
}

decl {\#include "PresetsUI.h"} {public local
}

decl {\#include "Synth/OscilGen.h"} {public local
}

decl {\#include "Misc/Config.h"} {public local
}

decl {\#include "Misc/SynthEngine.h"} {public local
}

decl {\#include "MasterUI.h"} {private global
}

decl {\#include "Misc/NumericFuncs.h"
    using func::dB2rap;
    using func::rap2dB;} {private local
}

class OscilSpectrum {: {public Fl_Box}
} {
  Function {OscilSpectrum(int x,int y, int w, int h, const char *label=0):Fl_Box(x,y,w,h,label)} {} {
    code {oscilSmp=NULL;} {}
  }
  Function {init(OscilGen *oscilSmp_,int oscbase_, SynthEngine *_synth)} {} {
    code {//
    synth = _synth;
    oscilSmp = oscilSmp_;
    oscbase = oscbase_;} {}
  }
  Function {draw()} {} {
    code {//
    int ox = x();
    int oy = y();
    int lx = w();
    int ly = h();
    const int maxdb = 60; // must be multiple of 10
    int GX = 2;
    int n = lx / GX - 1;
    if (n > synth->halfoscilsize)
        n = synth->halfoscilsize;

    float x;
    float* spc = new float[n];
    for (int i = 0; i < n; ++i)
        spc[i] = 0.0;

    if (oscbase == 0)
        oscilSmp->getspectrum(n, spc, 0);
    else
        oscilSmp->getspectrum(n, spc, 1);

    // normalize
    float max = 0;
    for (int i = 0; i < n; ++i)
    {
        x = fabsf(spc[i]);
        if (max < x)
            max = x;
    }
    if (max < 0.000001)
        max = 1.0;
    max = max * 1.05;

    // draw
    if (this->active_r())
        fl_color(this->parent()->selection_color());
    else
        fl_color(this->parent()->color());

    for (int i = 1; i < maxdb / 10; ++i)
    {
        int ky = int((float)i * ly * 10.0 / maxdb) / 2;
        ky *= 2;
        fl_line(ox, oy + ky - 1, ox + lx - 2, oy + ky - 1);
    }

    for (int i = 2; i < n; ++i)
    {
        int tmp = i * GX - 2;
        fl_line(ox + tmp, oy + 2, ox + tmp, oy + ly - 2);
    }
    if (this->active_r())
        fl_color(this->parent()->labelcolor());
    else
        fl_color(this->parent()->color());

    // draws the spectrum
    for (int i = 0; i < n; ++i)
    {
        int tmp = i * GX + 2;
        x = spc[i] / max;

        if (x > dB2rap(-maxdb))
            x = rap2dB(x) / maxdb + 1;
        else
            x = 0;

        int val = int((ly - 2) * x);
        if (val > 0)
            fl_line(ox + tmp, oy + ly - 2 - val, ox + tmp, oy + ly - 2);
    }
    delete [] spc;} {}
  }
  decl {OscilGen *oscilSmp;} {private local
  }
  decl {int oscbase;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
}

class PSlider {: {public mwheel_slider}
} {
  Function {PSlider(int x,int y, int w, int h, const char *label=0):mwheel_slider(x,y,w,h,label)} {} {
    code {;} {}
  }
  Function {handle(int event)} {return_type int
  } {
    code {int X=x(),Y=y(),W=w(),H=h();

    if ((!Fl::event_buttons())|| (event==0)||(Fl::event_shift()==0))
        return(mwheel_slider::handle(event));

    if (!Fl::event_inside(X,Y,W,H))
    {
        if (event==FL_DRAG)
        {
            mwheel_slider::handle(FL_RELEASE);
            mwheel_slider::handle(FL_LEAVE);
            deactivate();
            activate();
            return(1);
        }
        else
        {
            return(mwheel_slider::handle(event));
        }
    }
    else
    {
        mwheel_slider::handle(FL_PUSH);
    }

    return(1);} {}
  }
}

class Oscilloscope {: {public Fl_Box}
} {
  Function {Oscilloscope(int x,int y, int w, int h, const char *label=0):Fl_Box(x,y,w,h,label)} {} {
    code {//
    oscilSmp=NULL;
    phase=64;
    oscbase=0;} {}
  }
  Function {init(OscilGen *oscilSmp_, SynthEngine *_synth)} {} {
    code {//
    synth = _synth;
    oscilSmp=oscilSmp_;} {}
  }
  Function {init(OscilGen *oscilSmp_,int oscbase_, SynthEngine *_synth)} {} {
    code {//
    synth = _synth;
    oscilSmp=oscilSmp_;
    oscbase=oscbase_;} {}
  }
  Function {init(OscilGen *oscilSmp_,int oscbase_,int phase_, SynthEngine *_synth)} {} {
    code {//
    synth = _synth;
    oscilSmp=oscilSmp_;
    oscbase=oscbase_;
    phase=phase_;} {}
  }
  Function {draw()} {} {
    code {//
    int ox = x();
    int oy = y();
    int lx = w();
    int ly = h() - 1;
    float smps[synth->oscilsize];
    if (oscbase == 0)
        oscilSmp->get(smps, -1.0);
    else
        oscilSmp->getcurrentbasefunction(smps);

    if (damage( )!= 1)
    {
        fl_color(0, 0, 0);
        fl_rectf(ox, oy, lx, ly);
    }

    // normalize
    float max = 0;
    for (int o = 0; o < synth->oscilsize; ++o)
    {
        if (max < fabsf(smps[o]))
            max = fabsf(smps[o]);
    }
    if (max < 0.00001)
        max = 1.0;
    max = -max * 1.05;

    // draw
    if (this->active_r())
        fl_color(this->parent()->labelcolor());
    else
        fl_color(this->parent()->color());
    int GX = 16;
    if (lx < GX * 3)
        GX = -1;
    for (int i = 1; i < GX; i++)
    {
        int tmp = int(lx / (float)GX * i);
        fl_line(ox + tmp, oy + 2, ox + tmp, oy + ly - 2);
    }
    int GY = 8;
    if (ly < GY * 3)
        GY = -1;
    for (int i = 1; i < GY; i++)
    {
        int tmp = int(ly / (float)GY * i);
        fl_line(ox + 2, oy + tmp, ox + lx - 2, oy + tmp);
    }

    // draw the function
    fl_line(ox + 2, oy + ly / 2, ox + lx - 2, oy + ly / 2);
    if (this->active_r())
        fl_color(this->parent()->selection_color());
    else
        fl_color(this->parent()->labelcolor());
    int ph = int((phase - 64.0) / 128.0 * synth->oscilsize_f + synth->oscilsize_f);
    for (int i = 1; i < lx; ++i)
    {
        int k1 = int(synth->oscilsize_f * (i - 1) / lx) + ph;
        int k2 = int(synth->oscilsize_f * i / lx) + ph;
        float y1 = smps[k1 % synth->oscilsize] / max;
        float y2 = smps[k2 % synth->oscilsize] / max;
        fl_line(i - 1 + ox, int(y1 * ly / 2.0) + oy + ly / 2, i + ox,
                int(y2 * ly / 2.0) + oy + ly / 2);
            }} {}
  }
  decl {OscilGen *oscilSmp;} {private local
  }
  decl {int oscbase;} {private local
  }
  decl {int phase;} {public local
  }
  decl {SynthEngine *synth;} {private local
  }
}

class Oscilharmonic {: {public Fl_Group}
} {
  Function {make_window()} {private
  } {
    Fl_Window harmonic {
      private xywh {329 192 50 225} type Double box NO_BOX labelsize 10 hide
      class Fl_Group
    } {
      Fl_Slider mag {
        callback {//
        int x=64;
        if (Fl::event_button3())
        {
            if (n == 0)
                x = 127;
            o->value(127 - x);
        }
        else
            x = 127 - (int)o->value();

        if (x==64)
            o->selection_color(0);
        else
            o->selection_color(222);

        send_data(TOPLEVEL::action::forceUpdate, TOPLEVEL::insert::harmonicAmplitude, n, x, TOPLEVEL::type::Integer);}
        xywh {0 1 15 122} type {Vert Knob} box FLAT_BOX selection_color 222 maximum 127 step 1 value 64
        code0 {o->value(127-oscil->Phmag[n]);}
        code1 {if (oscil->Phmag[n]==64) o->selection_color(0);}
        class PSlider
      }
      Fl_Slider phase {
        callback {//
        int x = 64;
        if (Fl::event_button3())
            o->value(x);
        else
            x = (int)o->value();

        if (x == 64)
            o->selection_color(0);
        else
            o->selection_color(222);

        send_data(TOPLEVEL::action::forceUpdate, TOPLEVEL::insert::harmonicPhaseBandwidth, n, 127 - x, TOPLEVEL::type::Integer);}
        xywh {0 140 15 82} type {Vert Knob} box FLAT_BOX selection_color 222 maximum 127 step 1 value 64
        code0 {o->value(oscil->Phphase[n]);}
        code1 {if (oscil->Phphase[n]==64) o->selection_color(0);}
        class PSlider
      }
      Fl_Box {} {
        xywh {15 60 5 5} box FLAT_BOX color 39
      }
      Fl_Box {} {
        xywh {15 178 5 5} box FLAT_BOX color 39
      }
      Fl_Box {} {
        xywh {-4 124 36 15} labelfont 1 labelsize 12 align 20
        code0 {if (n < 99 || (n & 1) == 0) {char tmp[12]; snprintf(tmp, 12, "%d", n + 1); o->label(strdup(tmp));}}
      }
    }
  }
  Function {Oscilharmonic(int x,int y, int w, int h, const char *label=0):Fl_Group(x,y,w,h,label)} {} {
    code {//
    n=0;
    oscil=NULL;
    display=NULL;
    applybutton=NULL;
    cbwidget=NULL;} {}
  }
  Function {send_data(int action, int insert, int control, float value, int type)} {} {
    code {//
        type |= TOPLEVEL::type::Write;
        collect_data(synth, value, action, (Fl::event_button() | type), control, npart, kititem, engine, insert);} {}
  }
  Function {init(OscilParameters *oscil_,int n_,Fl_Group *display_,Fl_Widget *oldosc_,Fl_Widget *cbwidget_,Fl_Widget *applybutton_, SynthEngine *_synth, int npart_, int kititem_, int engine_)} {} {
    code {//
    synth = _synth;
    oscil=oscil_;
    n=n_;
    npart = npart_;
    kititem = kititem_;
    engine = engine_;
    display=display_;
    oldosc=oldosc_;
    cbwidget=cbwidget_;
    applybutton=applybutton_;
    make_window();
    end();
    harmonic->show();} {}
  }
  Function {refresh()} {} {
    code {//
    mag->value(127-oscil->Phmag[n]);
    phase->value(oscil->Phphase[n]);

    if (oscil->Phmag[n]==64)
        mag->selection_color(0);
    else
        mag->selection_color(222);

    if (oscil->Phphase[n]==64)
        phase->selection_color(0);
    else
        phase->selection_color(222);} {}
  }
  Function {~Oscilharmonic()} {} {
    code {//
    harmonic->hide();} {}
  }
  decl {OscilParameters *oscil;} {private local
  }
  decl {Fl_Group *display;} {private local
  }
  decl {int n;} {private local
  }
  decl {Fl_Widget *oldosc,*cbwidget,*applybutton;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
  decl {int npart;} {private local
  }
  decl {int kititem;} {private local
  }
  decl {int engine;} {private local
  }
}

class OscilEditor {: {public PresetsUI_}
} {
  Function {make_window()} {} {
    Fl_Window osceditUI {
      label {ADsynth Oscillator Editor}
      xywh {4 48 735 595} type Double hide
      code0 {string tname;}
      code1 {setWindowTitle();}
    } {
      Fl_Button applybutton {
        label Apply
        callback {//
        send_data(TOPLEVEL::action::forceUpdate, PART::control::padsynthParameters, 0, TOPLEVEL::type::Integer);}
        xywh {300 280 60 20} box THIN_UP_BOX labelfont 1
        code0 {if (!oscil->ADvsPAD) o->hide();}
      }
      Fl_Group oscildisplaygroup {
        xywh {5 5 360 300} box ENGRAVED_FRAME
      } {
        Fl_Group waveformgroup {
          xywh {10 85 350 190} box THIN_DOWN_BOX color 32 selection_color 71 labelcolor 179
          code0 {Oscilloscope *osc=new Oscilloscope(o->x(),o->y(),o->w(),o->h(),"");}
          code1 {osc->init(oscilSmp, synth);}
        } {}
        Fl_Group harmonicgroup {
          xywh {10 30 350 50} box THIN_DOWN_BOX color 32 selection_color 218 labelcolor 63
          code0 {OscilSpectrum *spc=new OscilSpectrum(o->x(),o->y(),o->w(),o->h(),"");}
          code1 {spc->init(oscilSmp,0, synth);}
        } {}
        Fl_Group {} {
          xywh {246 277 115 25} box ENGRAVED_BOX
          code0 {if (oscil->ADvsPAD) o->hide();}
        } {
          Fl_Choice hrndtype {
            label {H.rnd}
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::harmonicRandomnessType, o->value(), TOPLEVEL::type::Integer);}
            tooltip {Harmonic Amplitude Randomness} xywh {281 282 50 15} down_box BORDER_BOX labelsize 10 textsize 10
          } {
            MenuItem {} {
              label None
              xywh {60 60 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Pow
              xywh {70 70 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Sin
              xywh {80 80 100 20} labelfont 1 labelsize 10
            }
          }
          Fl_Dial hrnddial {
            callback {//
            send_data(0, OSCILLATOR::control::harmonicAmplitudeRandomness, o->value(), TOPLEVEL::type::Integer);}
            tooltip {Oscillator's harmonic randomness parameter} xywh {338 280 18 18} maximum 127 step 1
            class WidgetPDial
          }
        }
      }
      Fl_Box {} {
        label Oscillator
        xywh {120 10 110 20} labelfont 1 labelsize 12
      }
      Fl_Value_Slider rndslider {
        label {Phase Randomness}
        callback {//
          if (Fl::event_button() == 3)
              o->value(0);

          send_data(0, OSCILLATOR::control::phaseRandomness, o->value(), TOPLEVEL::type::Integer);}
        tooltip {Oscilator Phase Randomness: smaller than 0 is "group", larger than 0 is for each harmonic} xywh {140 285 100 15} type {Horz Knob} box THIN_DOWN_BOX labelsize 10 align 1 minimum -64 maximum 63 step 1
        code0 {if (oscil->ADvsPAD) o->hide();}
        class mwheel_val_slider_rev
      }
      Fl_Group basefuncdisplaygroup {
        xywh {365 5 360 300} box ENGRAVED_FRAME
      } {
        Fl_Group basewave {
          xywh {370 85 350 190} box THIN_DOWN_BOX color 32 selection_color 71 labelcolor 179
          code0 {Oscilloscope *osc=new Oscilloscope(o->x(),o->y(),o->w(),o->h(),"");}
          code1 {osc->init(oscilSmp,1, synth);}
        } {}
        Fl_Dial bfslider {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseFunctionParameter, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Base Function Parameter} xywh {520 280 20 20} minimum -64 maximum 63 step 1
          class WidgetPDial
        }
        Fl_Choice bftype {
          label {Base Function}
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseFunctionType, o->value(), TOPLEVEL::type::Integer);}
          xywh {370 285 90 15} down_box BORDER_BOX labelsize 10 align 1 textsize 11
        } {
          MenuItem {} {
            label Sine
            xywh {10 10 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Triangle
            xywh {20 20 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Pulse
            xywh {30 30 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Saw
            xywh {40 40 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Power
            xywh {50 50 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Gauss
            xywh {50 50 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Diode
            xywh {60 60 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label AbsSine
            xywh {70 70 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label PulseSine
            xywh {80 80 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label StrchSine
            xywh {90 90 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Chirp
            xywh {100 100 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label AbsStrSine
            xywh {102 102 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Chebyshev
            xywh {112 112 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Sqr
            xywh {122 122 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Spike
            xywh {122 132 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label Circle
            xywh {122 142 100 20} labelfont 1 labelsize 11
          }
          MenuItem {} {
            label User
            xywh {122 152 100 20} labelfont 1 labelsize 11 hide
          }
        }
        Fl_Box {} {
          label {Base Function}
          xywh {480 10 110 20} box FLAT_BOX labelfont 1 labelsize 12
        }
        Fl_Group baseharm {
          xywh {370 30 350 50} box THIN_DOWN_BOX color 32 selection_color 218 labelcolor 63
          code0 {OscilSpectrum *spc=new OscilSpectrum (o->x(),o->y(),o->w(),o->h(),"");}
          code1 {spc->init(oscilSmp,1, synth);}
        } {}
        Fl_Box {} {
          label {Par.}
          xywh {460 285 30 16} box FLAT_BOX labelsize 11
        }
        Fl_Value_Output bfparval {
          xywh {490 285 28 15} labelsize 12 align 20 minimum -63 maximum 63 step 1
        }
        Fl_Group basefuncmodulation {
          xywh {550 276 169 25} box ENGRAVED_BOX
          code0 {if ((oscil->Pcurrentbasefunc==0)||(oscil->Pcurrentbasefunc==127)) basefuncmodulation->deactivate();}
        } {
          Fl_Group baseFuncPars {
            xywh {652 278 66 21}
          } {
            Fl_Dial bfmodpar1 {
              callback {//
            send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseModulationParameter1, o->value(), TOPLEVEL::type::Integer);}
              tooltip {Oscillator's modulation parameter 1} xywh {654 280 17 17} maximum 127 step 1
              class WidgetPDial
            }
            Fl_Dial bfmodpar2 {
              callback {//
            send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseModulationParameter2, o->value(), TOPLEVEL::type::Integer);}
              tooltip {Oscillator's modulation parameter 2} xywh {676 280 17 17} maximum 127 step 1
              class WidgetPDial
            }
            Fl_Dial bfmodpar3 {
              callback {//
            send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseModulationParameter3, o->value(), TOPLEVEL::type::Integer);}
              tooltip {Oscillator's modulation parameter 3} xywh {698 280 17 17} maximum 127 step 1
              class WidgetPDial
            }
          }
          Fl_Choice bfmodtype {
            label {B.F.Mod.}
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::baseModulationType, o->value(), TOPLEVEL::type::Integer);}
            tooltip {Base function modulation} xywh {599 281 50 15} down_box BORDER_BOX labelsize 10 textsize 10
          } {
            MenuItem {} {
              label None
              xywh {50 50 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Rev
              xywh {60 60 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Sine
              xywh {70 70 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Pow
              xywh {80 80 100 20} labelfont 1 labelsize 10
            }
          }
        }
      }
      Fl_Output Warning {
        xywh {224 8 248 20} box FLAT_BOX color 29 align 32 textfont 1 textcolor 1
      }
      Fl_Choice magtype {
        label {Mag.Type}
        callback {//
        send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::magType, o->value(), TOPLEVEL::type::Integer);}
        xywh {70 280 65 20} down_box BORDER_BOX labelsize 11 textsize 11
      } {
        MenuItem {} {
          label Linear
          xywh {0 0 100 20} labelfont 1 labelsize 11
        }
        MenuItem {} {
          label {-40dB}
          xywh {10 10 100 20} labelfont 1 labelsize 11
        }
        MenuItem {} {
          label {-60dB}
          xywh {20 20 100 20} labelfont 1 labelsize 11
        }
        MenuItem {} {
          label {-80dB}
          xywh {30 30 100 20} labelfont 1 labelsize 11
        }
        MenuItem {} {
          label {-100dB}
          xywh {40 40 100 20} labelfont 1 labelsize 11
        }
      }
      Fl_Button {} {
        label {Use as base}
        callback {//
        send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::useAsBaseFunction, autoclearbutton->value() > 0, TOPLEVEL::type::Integer);}
        tooltip {Use this Oscillator as base function} xywh {5 313 85 20} box THIN_UP_BOX labelfont 1 labelsize 11
      }
      Fl_Button {} {
        label Close
        callback {//
        osceditUI->hide();
        if ((Fl::event_button() == 3))
        {
            if (oscil->ADvsPAD)
                synth->getGuiMaster()->partui->padnoteui->padnotewindow->show();
            else
                synth->getGuiMaster()->partui->adnoteui->ADnoteVoice->show();
        }}
        tooltip {Right click: also reopen previous} xywh {668 565 62 25} box THIN_UP_BOX
      }
      Fl_Button clearHarm {
        label Clear
        callback {//
        if (fl_choice("Clear the harmonics settings?", NULL,"No","Yes") < 2)
            return;
        send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::clearHarmonics, o->value(), TOPLEVEL::type::Integer);}
        xywh {670 505 55 15} box THIN_UP_BOX labelfont 1 labelsize 11
      }
      Fl_Group {} {
        xywh {135 308 150 30} box ENGRAVED_BOX
      } {
        Fl_Choice wshbutton {
          label {Wsh.}
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::waveshapeType, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Waveshaping function} xywh {165 313 55 20} down_box BORDER_BOX labelsize 10 textsize 10
        } {
          MenuItem {} {
            label None
            xywh {25 25 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Atan
            xywh {35 35 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Asym1
            xywh {45 45 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Pow
            xywh {55 55 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Sine
            xywh {65 65 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Qnts
            xywh {75 75 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Zigzg
            xywh {85 85 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Lmt
            xywh {95 95 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label LmtU
            xywh {105 105 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label LmtL
            xywh {115 115 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label ILmt
            xywh {127 127 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Clip
            xywh {137 137 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Asym2
            xywh {85 85 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Pow2
            xywh {95 95 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Sgm
            xywh {90 90 100 20} labelfont 1 labelsize 10
          }
        }
        Fl_Dial wshpar {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::waveshapeParameter, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Waveshaping Parameter} xywh {260 313 20 20} minimum -64 maximum 63 step 1
          class WidgetPDial
        }
        Fl_Value_Output wsparval {
          xywh {228 316 25 15} labelsize 12 minimum -63 maximum 63 step 1
        }
      }
      Fl_Light_Button autoclearbutton {
        label {Clr.}
        callback {// not used directly now
        (void) o; // suppress warning
        //send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::autoClear, o->value(), TOPLEVEL::type::Integer);}
        tooltip {Auto clear when using the oscillator as base function} xywh {95 313 35 20} box THIN_UP_BOX value 1 labelfont 1 labelsize 10
      }
      Fl_Group filterGroup {
        xywh {285 308 155 30} box ENGRAVED_BOX
      } {
        Fl_Dial filtervalue1 {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::filterParameter1, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's filter parameter1} xywh {367 313 20 20} maximum 127 step 1
          class WidgetPDial
        }
        Fl_Check_Button filterpref {
          label F
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::filterBeforeWaveshape, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Apply the filter before the waveshaping} xywh {415 313 20 20} down_box DOWN_BOX labelsize 10 align 24
        }
        Fl_Dial filtervalue2 {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::filterParameter2, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's filter parameter2} xywh {392 313 20 20} maximum 127 step 1
          class WidgetPDial
        }
      }
      Fl_Choice fltbutton {
        label Filter
        callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::filterType, o->value(), TOPLEVEL::type::Integer);}
        tooltip {Oscillator's filter type} xywh {315 313 50 20} down_box BORDER_BOX labelsize 10 textsize 10
      } {
        MenuItem {} {
          label None
          xywh {45 45 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label LP1
          xywh {55 55 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label HP1a
          xywh {65 65 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label HP1b
          xywh {75 75 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label BP1
          xywh {85 85 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label BS1
          xywh {95 95 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label LP2
          xywh {65 65 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label HP2
          xywh {75 75 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label BP2
          xywh {75 75 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label BS2
          xywh {85 85 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Cos
          xywh {85 85 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Sin
          xywh {95 95 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label LSh
          xywh {105 105 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label S
          xywh {115 115 100 20} labelfont 1 labelsize 10
        }
      }
      Fl_Group {} {
        xywh {594 308 136 30} box ENGRAVED_BOX
      } {
        Fl_Choice sabutton {
          label {Sp.adj.}
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::spectrumAdjustType, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's spectrum adjust} xywh {634 313 60 20} down_box BORDER_BOX labelsize 10 textsize 10
        } {
          MenuItem {} {
            label None
            xywh {55 55 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label Pow
            xywh {65 65 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label ThrsD
            xywh {75 75 100 20} labelfont 1 labelsize 10
          }
          MenuItem {} {
            label ThrsU
            xywh {85 85 100 20} labelfont 1 labelsize 10
          }
        }
        Fl_Dial sadjpar {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::spectrumAdjustParameter, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's spectrum adjust parameter} xywh {699 313 20 20} maximum 127 step 1
          class WidgetPDial
        }
      }
      Fl_Group {} {
        xywh {665 340 65 65} box ENGRAVED_BOX
      } {
        Fl_Counter harmonicshiftcounter {
          label {Harmonic Shift}
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::harmonicShift, o->value(), TOPLEVEL::type::Integer);}
          xywh {670 365 55 15} type Simple labelsize 10 align 129 minimum -64 maximum 64 step 1 textfont 1 textsize 10
        }
        Fl_Check_Button harmonicshiftpre {
          label {Shift 1st}
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::shiftBeforeWaveshapeAndFilter, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Apply the harmonic shift before the waveshaping and filtering} xywh {668 383 56 20} down_box DOWN_BOX labelsize 10 align 24
        }
      }
      Fl_Group adaptiveGroup {
        xywh {665 410 65 90} box ENGRAVED_FRAME
      } {
        Fl_Dial adhrpow {
          label pow
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::adaptiveHarmonicsPower, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Adaptive harmonics power} xywh {700 460 25 25} labelsize 10 maximum 200 step 1
          class WidgetPDial
        }
        Fl_Dial adhrbf {
          label baseF
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::adaptiveHarmonicsBase, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Adaptive harmonics base frequency} xywh {670 460 25 25} labelsize 10 maximum 255 step 1
          class WidgetPDial
        }
        Fl_Slider adhrpar {
          callback {//
          if (Fl::event_button() == 3)
              o->value(50);

          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::adaptiveHarmonicsParameter, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Adaptive harmonics parameter} xywh {667 444 60 13} type {Horz Knob} box THIN_DOWN_BOX maximum 100 step 1 value 50
          class mwheel_slider_rev
        }
      }
      Fl_Choice adhrtype {
        label {Adpt.Harm.}
        callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::adaptiveHarmonicsType, o->value(), TOPLEVEL::type::Integer);}
        tooltip {The type of the addaptive harmonics} xywh {670 425 55 15} down_box BORDER_BOX labelsize 10 align 129 when 6 textsize 10
      } {
        MenuItem {} {
          label OFF
          xywh {90 90 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label ON
          xywh {100 100 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Square
          xywh {110 110 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 2xSub
          xywh {120 120 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 2xAdd
          xywh {130 130 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 3xSub
          xywh {130 130 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 3xAdd
          xywh {140 140 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 4xSub
          xywh {140 140 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label 4xAdd
          xywh {150 150 100 20} labelfont 1 labelsize 10
        }
      }
      Fl_Group modulationGroup {
        xywh {440 308 154 30} box ENGRAVED_BOX
      } {
        Fl_Dial modpar1 {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::modulationParameter1, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's modulation parameter 1} xywh {524 314 18 18} maximum 127 step 1
          class WidgetPDial
        }
        Fl_Dial modpar2 {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::modulationParameter2, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's modulation parameter 2} xywh {546 314 18 18} maximum 127 step 1
          class WidgetPDial
        }
        Fl_Dial modpar3 {
          callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::modulationParameter3, o->value(), TOPLEVEL::type::Integer);}
          tooltip {Oscillator's modulation parameter 3} xywh {569 314 18 18} maximum 127 step 1
          class WidgetPDial
        }
      }
      Fl_Choice modtype {
        label {Mod.}
        callback {//
          send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::modulationType, o->value(), TOPLEVEL::type::Integer);}
        tooltip modulation xywh {470 315 50 15} down_box BORDER_BOX labelsize 10 textsize 10
      } {
        MenuItem {} {
          label None
          xywh {70 70 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Rev
          xywh {80 80 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Sine
          xywh {90 90 100 20} labelfont 1 labelsize 10
        }
        MenuItem {} {
          label Pow
          xywh {100 100 100 20} labelfont 1 labelsize 10
        }
      }
      Fl_Button {} {
        label Sine
        callback {//
        if (fl_choice("Convert to SINE?",NULL, "No","Yes") < 2)
            return;

        send_data(TOPLEVEL::action::forceUpdate, OSCILLATOR::control::convertToSine, o->value(), TOPLEVEL::type::Integer);}
        xywh {670 525 55 15} box THIN_UP_BOX labelfont 1 labelsize 11
      }
      Fl_Button {} {
        label C
        callback {synth->getGuiMaster()->getPresetsUi()->copy(oscil);}
        xywh {670 545 25 15} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
      }
      Fl_Button {} {
        label P
        callback {synth->getGuiMaster()->getPresetsUi()->paste(oscil,this);}
        xywh {700 545 25 15} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
      }
      Fl_Scroll _this_has_to_be_the_last {
        xywh {5 340 660 250} type HORIZONTAL box ENGRAVED_FRAME
      } {
        Fl_Pack harmonics {
          xywh {10 345 650 225} type HORIZONTAL
          code0 {for (int i=0;i<MAX_AD_HARMONICS;i++){h[i]=new Oscilharmonic(0,0,20,o->h(),"");h[i]->init(oscil,i,oscildisplaygroup,oldosc,cbwidget,applybutton, synth, npart, kititem, engine);}}
        } {}
      }
    }
  }
  Function {send_data(int action, int control, float value, int type)} {} {
    code {//
        int insert = TOPLEVEL::insert::oscillatorGroup;
        if (control == PART::control::padsynthParameters)
            insert = UNUSED;
        type |= TOPLEVEL::type::Write;
        collect_data(synth, value, action, (Fl::event_button() | type), control, npart, kititem, engine, insert);} {}
  }
  Function {returns_update(CommandBlock *getData)} {} {
    code {//
    float value = getData->data.value.F;
    unsigned char control = getData->data.control;
    unsigned char eng = getData->data.engine;
    unsigned char insert = getData->data.insert;

    //if (eng != engine)
        //return;

    int tmp;
    bool set = true;
    bool baseSet = false;
    if (insert == TOPLEVEL::insert::harmonicAmplitude)
    {
        h[control]->mag->value(127 - value);
        if (value == 64)
            h[control]->mag->selection_color(0);
        else
            h[control]->mag->selection_color(222);
    }

    else if (insert == TOPLEVEL::insert::harmonicPhaseBandwidth)
    {
        h[control]->phase->value(127 - value);
        if (value == 64)
            h[control]->phase->selection_color(0);
        else
            h[control]->phase->selection_color(222);
    }

    else
    {
        switch (control)
        {
            case OSCILLATOR::control::phaseRandomness:
                rndslider->value(value);
                break;

            case OSCILLATOR::control::magType:
                magtype->value(value);
                break;

            case OSCILLATOR::control::harmonicAmplitudeRandomness:
                hrnddial->value(value);
                break;

            case OSCILLATOR::control::harmonicRandomnessType:
                hrndtype->value(value);
                if (value < 0.5f)
                    hrnddial->deactivate();
                else
                    hrnddial->activate();
                break;

            case OSCILLATOR::control::baseFunctionParameter:
                bfslider->value(value);
                bfparval->value(value);
                baseSet = true;
                break;

            case OSCILLATOR::control::baseFunctionType:
                bftype->value(value);
                if (value < 0.5f)
                    bfslider->deactivate();
                else
                    bfslider->activate();
                if ((oscil->Pcurrentbasefunc==0)||(oscil->Pcurrentbasefunc==127))
                    basefuncmodulation->deactivate();
                else
                    basefuncmodulation->activate();
                baseSet = true;
                break;

            case OSCILLATOR::control::baseModulationParameter1:
                bfmodpar1->value(value);
                baseSet = true;
                redrawoscil();
                break;

            case OSCILLATOR::control::baseModulationParameter2:
                bfmodpar2->value(value);
                baseSet = true;
                redrawoscil();
                break;

            case OSCILLATOR::control::baseModulationParameter3:
                bfmodpar3->value(value);
                baseSet = true;
                redrawoscil();
                break;

            case OSCILLATOR::control::baseModulationType:
                bfmodtype->value(value);
                if (value< 0.5f)
                    baseFuncPars->deactivate();
                else
                    baseFuncPars->activate();
                baseSet = true;
                redrawoscil();
                break;

            case OSCILLATOR::control::useAsBaseFunction:
                bftype->value(16);
                tmp = (value != 0);
                autoclearbutton->value(tmp);
                if (tmp)
                {
                    for (int i = 0; i<MAX_AD_HARMONICS; ++i)
                    {
                        h[i]->mag->value(64);;
                        h[i]->phase->value(64);
                    }
                    h[0]->mag->value(127);
                    harmonicshiftcounter->value(0);
                    h[0]->mag->value(0);
                    wshbutton->value(0);
                    fltbutton->value(0);
                    sabutton->value(0);
                }
                for (int i = 0; i<MAX_AD_HARMONICS; ++i)
                {
                    if (h[i]->mag->value() == 64)
                        h[i]->mag->selection_color(0);
                    else
                        h[i]->mag->selection_color(222);

                    if (h[i]->phase->value() == 64)
                        h[i]->phase->selection_color(0);
                    else
                        h[i]->phase->selection_color(222);
                }
                baseSet = true;
                set = false;
                break;

            case OSCILLATOR::control::waveshapeParameter:
                wshpar->value(value);
                wsparval->value(value);
                break;

            case OSCILLATOR::control::waveshapeType:
                wshbutton->value(value);
                if (value < 0.5f)
                    wshpar->deactivate();
                else
                    wshpar->activate();
                break;

            case OSCILLATOR::control::filterParameter1:
                filtervalue1->value(value);
                break;

            case OSCILLATOR::control::filterParameter2:
                filtervalue2->value(value);
                break;

            case OSCILLATOR::control::filterBeforeWaveshape:
                filterpref->value(value != 0);
                break;

            case OSCILLATOR::control::filterType:
                fltbutton->value((int)value);
                if (value < 0.5f)
                    filterGroup->deactivate();
                else
                    filterGroup->activate();
                break;

            case OSCILLATOR::control::modulationParameter1:
                modpar1->value(value);
                break;

            case OSCILLATOR::control::modulationParameter2:
                modpar2->value(value);
                break;

            case OSCILLATOR::control::modulationParameter3:
                modpar3->value(value);
                break;

            case OSCILLATOR::control::modulationType:
                modtype->value((int)value);
                if (value < 0.5f)
                    modulationGroup->deactivate();
                else
                    modulationGroup->activate();
                break;

            case OSCILLATOR::control::spectrumAdjustParameter:
                sadjpar->value(value);
                break;

            case OSCILLATOR::control::spectrumAdjustType:
                sabutton->value((int)value);
                if (value < 0.5f)
                    sadjpar->deactivate();
                else
                    sadjpar->activate();
                break;

            case OSCILLATOR::control::harmonicShift:
                harmonicshiftcounter->value((int)value);
                break;

            case OSCILLATOR::control::clearHarmonicShift:
                harmonicshiftcounter->value(0);
                break;

            case OSCILLATOR::control::shiftBeforeWaveshapeAndFilter:
                harmonicshiftpre->value(value != 0);
                break;

            case OSCILLATOR::control::adaptiveHarmonicsParameter:
                adhrpar->value(value);
                break;

            case OSCILLATOR::control::adaptiveHarmonicsBase:
                adhrbf->value(value);
                break;

            case OSCILLATOR::control::adaptiveHarmonicsPower:
                adhrpow->value(value);
                break;

            case OSCILLATOR::control::adaptiveHarmonicsType:
                adhrtype->value((int)value);
                if (value < 0.5f)
                    adaptiveGroup->deactivate();
                else
                    adaptiveGroup->activate();
                break;

            case OSCILLATOR::control::clearHarmonics:
                for (int i = 0; i < MAX_AD_HARMONICS; ++i)
                {
                    h[i]->mag->value(64);
                    h[i]->mag->selection_color(0);
                    h[i]->phase->value(64);
                    h[i]->phase->selection_color(0);
                }
                h[0]->mag->value(0);
                h[0]->mag->selection_color(222);
                break;

            case OSCILLATOR::control::convertToSine:
                bftype->value(0);
                for (int i = 0; i < MAX_AD_HARMONICS; ++i)
                    h[i]->refresh();
                baseSet = true;
                set = false;
                break;

            default:
                set = false;
        }
    }
    if (baseSet)
    {
        basewave->redraw();
        baseharm->redraw();
    }
    if (set)
    {
        waveformgroup->redraw();
        harmonicgroup->redraw();
        oldosc->redraw();
        if (eng == 2)
        {
            applybutton->color(FL_RED);
            applybutton->redraw();
        }
    }} {}
  }
  Function {fetchData(float value, int control, int part, int kititem = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int offset = UNUSED, int miscmsg = UNUSED, int request = UNUSED)} {return_type float
  } {
    code {//
        return collect_readData(synth, value, control, part, kititem, engine, insert, parameter, offset, miscmsg, request);} {}
  }
  Function {OscilEditor(OscilParameters *oscil_, Fl_Widget *oldosc_, Fl_Widget *cbwidget_, Fl_Widget *cbapplywidget_, SynthEngine *_synth, int npart_, int kititem_, int engine_)} {} {
    code {//
    synth = _synth;
    npart = npart_;
    kititem = kititem_;
    engine = engine_;
    oscil = oscil_;
    fft = new FFTwrapper(synth->oscilsize);
    oscilSmp = new OscilGen(fft, NULL, synth, oscil);
    oldosc = oldosc_;
    cbwidget = cbwidget_;
    cbapplywidget=cbapplywidget_;
    make_window();
    refresh();
    osceditUI->show();} {}
  }
  Function {~OscilEditor()} {return_type virtual
  } {
    code {osceditUI->hide();
    delete (osceditUI);
    delete oscilSmp;
    delete fft;} {}
  }
  Function {refresh()} {} {
    code {//
    magtype->value(oscil->Phmagtype);
    rndslider->value(oscil->Prand-64);

    hrndtype->value(oscil->Pamprandtype);
    if (hrndtype->value() == 0)
        hrnddial->deactivate();
    else
        hrnddial->activate();
    hrnddial->value(oscil->Pamprandpower);

    if (oscil->Pcurrentbasefunc == 127)
        bftype->value(16);
    else
        bftype->value(oscil->Pcurrentbasefunc);
    if (bftype->value() == 0)
        bfslider->deactivate();
    else
        bfslider->activate();
    bfparval->value(oscil->Pbasefuncpar-64);
    bfslider->value(oscil->Pbasefuncpar-64);

    bfmodtype->value(oscil->Pbasefuncmodulation);
    if (bfmodtype->value() == 0)
        baseFuncPars->deactivate();
    else
        baseFuncPars->activate();
    bfmodpar1->value(oscil->Pbasefuncmodulationpar1);
    bfmodpar2->value(oscil->Pbasefuncmodulationpar2);
    bfmodpar3->value(oscil->Pbasefuncmodulationpar3);

    wshbutton->value(oscil->Pwaveshapingfunction);
    if (wshbutton->value() == 0)
        wshpar->deactivate();
    else
        wshpar->activate();
    wsparval->value(oscil->Pwaveshaping-64);
    wshpar->value(oscil->Pwaveshaping-64);

    fltbutton->value(oscil->Pfiltertype);
    if (fltbutton->value() == 0)
        filterGroup->deactivate();
    else
        filterGroup->activate();
    filtervalue1->value(oscil->Pfilterpar1);
    filtervalue2->value(oscil->Pfilterpar2);
    filterpref->value(oscil->Pfilterbeforews);

    modtype->value(oscil->Pmodulation);
    if (modtype->value() == 0)
        modulationGroup->deactivate();
    else
        modulationGroup->activate();
    modpar1->value(oscil->Pmodulationpar1);
    modpar2->value(oscil->Pmodulationpar2);
    modpar3->value(oscil->Pmodulationpar3);

    sabutton->value(oscil->Psatype);
    if (sabutton->value() == 0)
        sadjpar->deactivate();
    else
        sadjpar->activate();
    sadjpar->value(oscil->Psapar);

    harmonicshiftcounter->value(oscil->Pharmonicshift);
    harmonicshiftpre->value(oscil->Pharmonicshiftfirst);

    adhrtype->value(oscil->Padaptiveharmonics);
    if (adhrtype->value() == 0)
        adaptiveGroup->deactivate();
    else
        adaptiveGroup->activate();
    adhrbf->value(oscil->Padaptiveharmonicsbasefreq);
    adhrpow->value(oscil->Padaptiveharmonicspower);
    adhrtype->value(oscil->Padaptiveharmonicspar);

    for (int i=0;i<MAX_AD_HARMONICS;i++)
        h[i]->refresh();

    oscilSmp->prepare();
    basewave->redraw();
    baseharm->redraw();
    redrawoscil();} {}
  }
  Function {setWindowTitle()} {} {
    code {//
        string tname;
        string warnType = "";
        if (engine == 2)
        {
            tname = "PadSynth Harmonic Content";
            Warning->hide();
        }
        else
        {
            tname = "AddSynth Voice ";
            int sourceEngine = -1;
            if (engine <= PART::engine::addVoice8)
            {
                tname = tname + to_string((engine - PART::engine::addVoice1) + 1);
                sourceEngine = fetchData(0, ADDVOICE::control::voiceOscillatorSource,npart,kititem, engine);
                warnType = "Voice " + to_string(sourceEngine + 1);
            }
            else
            {
                tname = tname + to_string((engine - PART::engine::addMod1) + 1) +  " Modulation";
                if (fetchData(0, ADDVOICE::control::externalModulator,npart,kititem, engine) == -1)
                {
                    sourceEngine = fetchData(0, ADDVOICE::control::modulatorOscillatorSource,npart,kititem, engine);
                    warnType = "Modulator " + to_string(sourceEngine + 1);
                };
            }
            Warning->redraw();

            tname += " Oscillator";
            if (sourceEngine > -1)
            {
                Warning->show();
                warnType = "WARNING: Editing " + warnType;
                Warning->value(warnType.c_str());
            }
            else
                Warning->hide();
        }
        osceditUI->copy_label(synth->getGuiMaster()->setPartWindowTitle(tname).c_str());} {}
  }
  Function {redrawoscil()} {} {
    code {//
    waveformgroup->redraw();
    harmonicgroup->redraw();
    oldosc->redraw();
    if (cbwidget!=NULL) {
        cbwidget->do_callback();
        applybutton->color(FL_RED);
        applybutton->redraw();
};} {}
  }
  decl {OscilParameters *oscil;} {private local
  }
  decl {FFTwrapper *fft;} {private local
  }
  decl {OscilGen *oscilSmp;} {private local
  }
  decl {Fl_Widget *oldosc,*cbwidget,*cbapplywidget;} {private local
  }
  decl {Oscilharmonic *h[MAX_AD_HARMONICS];} {private local
  }
  decl {int npart;} {private local
  }
  decl {int kititem;} {private local
  }
  decl {int engine;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
}
