# data file for the Fltk User Interface Designer (fluid)
version 1.0308
header_name {.h}
code_name {.cc}
comment {MasterUI.h} {not_in_source in_header
}

comment {MasterUI.cc} {in_source not_in_header
}

comment {Original ZynAddSubFX author Nasca Octavian Paul
Copyright (C) 2002-2005 Nasca Octavian Paul
Copyright 2009-2011, Alan Calvert
Copyright 2014-2024, Will Godfrey & others

This file is part of yoshimi, which is free software: you can redistribute
it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.

yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
later) for more details.

You should have received a copy of the GNU General Public License along with
yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA.

This file is a derivative of the ZynAddSubFX original.} {selected in_source in_header
}

decl {\#define PANEL_SINGLE_X 1040} {public local
}

decl {\#define PANEL_SINGLE_Y 320} {public local
}

decl {\#define PANEL_DUAL_X 530} {public local
}

decl {\#define PANEL_DUAL_Y 600} {public local
}

decl {\#include <FL/Fl_Tooltip.H>} {public local
}

decl {\#include <FL/Fl_Box.H>} {public local
}

decl {\#include <string>} {public local
}

decl {\#include <iostream>} {public local
}

decl {\#include <deque>} {public local
}

decl {\#include <fstream>} {public local
}

decl {\#include "UI/MiscGui.h"} {public local
}

decl {\#include "UI/WidgetCheckButton.h"} {public local
}

decl {\#include "UI/WidgetSpinner.h"} {public local
}

decl {\#include "ADnoteUI.h"} {public local
}

decl {\#include "SUBnoteUI.h"} {public local
}

decl {\#include "EffUI.h"} {public local
}

decl {\#include "VirKeyboardUI.h"} {public local
}

decl {\#include "ConfigUI.h"} {public local
}

decl {\#include "BankUI.h"} {public local
}

decl {\#include "PartUI.h"} {public local
}

decl {\#include "MicrotonalUI.h"} {public local
}

decl {\#include "PresetsUI.h"} {public local
}

decl {\#include "ParametersUI.h"} {public local
}

decl {\#include "VectorUI.h"} {public local
}

decl {\#include "ConsoleUI.h"} {public local
}

decl {\#include "MasterMiscUI.h"} {public local
}

decl {\#include "Misc/SynthEngine.h"} {public local
}

decl {\#include "Interface/InterChange.h"} {public local
}

decl {\#include "Interface/InterfaceAnchor.h"
    using RoutingTag = GuiDataExchange::RoutingTag;} {public local
}

decl {\#include "MidiLearnUI.h"} {public local
}

decl {extern SynthEngine *firstSynth;} {public local
}

decl {\#include "Misc/FileMgrFuncs.h"
    using file::isRegularFile;
    using file::findLeafName;} {private local
}

decl {\#include "Misc/FormatFuncs.h"
    using func::string2uint;
    using func::asString;} {private local
}

decl {\#include "Misc/TextMsgBuffer.h"

    namespace { // Implementation details...
        TextMsgBuffer& textMsgBuffer = TextMsgBuffer::instance();
    }} {private local
}

decl {using std::to_string;} {private global
}

decl {int lineitem;} {public local
}

class FilerLine {: {public Fl_Group}
} {
  Function {make_window()} {} {
    Fl_Window filerlist {
      xywh {522 305 440 20} type Double color 7 hide
      class Fl_Group
    } {
      Fl_Group fileIcon {
        xywh {0 0 23 30} box FLAT_BOX color 7
      } {
        Fl_Box outer_box {
          xywh {3 0 16 20} box GTK_THIN_UP_BOX color 174 labeltype NO_LABEL
        }
        Fl_Box inner_box {
          xywh {5 2 12 16} box GTK_THIN_DOWN_BOX color 174 labeltype NO_LABEL
        }
        Fl_Box line1 {
          xywh {7 5 8 2} box FLAT_BOX color 124
        }
        Fl_Box line2 {
          xywh {7 9 8 2} box FLAT_BOX color 124
        }
        Fl_Box type {
          label xiz
          xywh {4 6 15 17} labelsize 4
        }
      }
      Fl_Group dirIcon {
        xywh {0 0 21 20} box FLAT_BOX color 7 hide
      } {
        Fl_Box {} {
          xywh {1 1 18 15} box PLASTIC_THIN_UP_BOX color 183
        }
        Fl_Box {} {
          xywh {3 4 18 16} box PLASTIC_THIN_UP_BOX color 183
        }
        Fl_Box {} {
          xywh {5 7 14 1} box DOWN_BOX
        }
      }
      Fl_Button name {
        xywh {25 0 415 21} box NO_BOX color 7 labelsize 12 labelcolor 64 align 20
      }
      Fl_Button nametop {
        callback {//std::cout << "pressed " << n << std::endl;
lineitem = n;}
        xywh {0 1 420 18} box NO_BOX labelcolor 64
      }
    }
  }
  Function {FilerLine(int x, int y, int w, int h, const char *label=0):Fl_Group(x,y,w,h,label)} {} {
    code {n = 0;} {}
  }
  decl {FilerLine(FilerLine const&) =delete;} {public local
  }
  decl {FilerLine(FilerLine&&) =delete;} {public local
  }
  decl {FilerLine& operator=(FilerLine const&) =delete;} {public local
  }
  decl {FilerLine& operator=(FilerLine&&) =delete;} {public local
  }
  Function {init(SynthEngine *synth_, int n_, bool isDir_, string typeName_, string title_)} {} {
    code {//

    synth = synth_;
    n = n_;
    isDir = isDir_;
    typeName = typeName_;
    title = title_;
    make_window();
    if (isDir)
    {
        dirIcon->show();
        fileIcon->hide();
    }
    else
    {
        dirIcon->hide();
        fileIcon->show();
        type->copy_label(typeName.c_str());
        name->copy_label(title.c_str());
    }
    show();
    end();} {}
  }
  decl {int n;} {private local
  }
  decl {bool isDir;} {private local
  }
  decl {string typeName;} {private local
  }
  decl {string title;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
  Function {~FilerLine()} {} {
    code {//
    filerlist->hide();
    delete (filerlist);} {}
  }
}

class KeyHandle {: {public Fl_Box}
} {
  Function {KeyHandle(int x,int y, int w, int h, const char *label=0):Fl_Box(x,y,w,h,label)} {} {
    code {} {}
  }
  Function {init(SynthEngine *_synth)} {} {
    code {//
        synth = _synth;} {}
  }
  Function {handle(int event)} {return_type int
  } {
    code {//
    int ev = 0;
    if (event == FL_FOCUS)
        ev = 1;
    else if (event == FL_UNFOCUS)
        ev = 1;
    else if (event == FL_SHORTCUT)
    {
        auto key = Fl::event_key();
        if (key == FL_Escape)
            ev = 1;
        else if (key == 'z')
        {
            if (Fl::event_state() == 327680) //ctrl + shift
            {
                synth->getGuiMaster()->redo->do_callback();
                ev = 1;
            }
             else if (Fl::event_ctrl())
             {
                 synth->getGuiMaster()->undo->do_callback();
                 ev = 1;
             }
        }
        else if (Fl::event_alt())
        {
            if(key == 'r')
            {
                synth->getGuiMaster()->redo->do_callback();
                ev = 1;
            }
            else if(key == 'u')
            {
                synth->getGuiMaster()->undo->do_callback();
                ev = 1;
            }
        }
    }
    return ev;} {}
  }
  decl {SynthEngine *synth;} {private local
  }
}

class MasterUI {: {public GuiUpdates}
} {
  Function {MasterUI(InterChange& _interChange, size_t slotIDX)
	 : GuiUpdates{_interChange, slotIDX}} {} {
    code {//
      synth = nullptr;
      presetsui = nullptr;
      npart = 0;
      panelgroup = 0;
      panelScale = 1;

      microtonalui = nullptr;
      bankui = nullptr;
      virkeyboard = nullptr;
      configui = nullptr;
      presetsui = nullptr;
      paramsui = nullptr;
      syseffectui = nullptr;
      inseffectui = nullptr;
      activePart = 0;
      yoshiLog = nullptr;
      queryDW = 0;

      lastmainW = -1;
      lastpanelW = 0;
      lastmsgW = 0;
      lasttextW = 0;
      lastsyseffW = 0;
      lastvirtW = 0;
      lastaboutW = 0;
      oldH = 0;

      filerpath.clear();
      lastfilerW = 0;} {}
  }
  Function {~MasterUI()} {} {
    code {//
      aboutwindow->hide();
      delete aboutwindow;

      syseffsendwindow->hide();
      if (syseffSeen)
          saveWin(synth, syseffsendwindow->w(), syseffsendwindow->h(), syseffsendwindow->x(), syseffsendwindow->y(), true, "Master-systemeffectsend");
      delete syseffsendwindow;

      if (panelType < 4)
          saveWin(synth, panelwindow->w(), panelwindow->h(), panelwindow->x(), panelwindow->y(), panelType, "Mixer");
      panelwindow->hide();
      delete panelwindow;

      message->hide();
      delete message;

      if (microtonalui)
          delete microtonalui;

      if (bankui)
          delete bankui;

      if (virkeyboard)
          delete virkeyboard;

      if (configui)
          delete configui;

      if (presetsui)
          delete presetsui;

      if (paramsui)
          delete paramsui;

      if (vectorui)
          delete vectorui;

      if (midilearnui)
          delete midilearnui;

      if (yoshiLog)
          delete yoshiLog;

      if (querywindow)
      {
          querywindow->hide();
          delete querywindow;
      }

      if (filerwindow)
      {
          filerlist.clear();
          if (filerwindow->visible())
              saveWin(synth, filerwindow->w(), filerwindow->h(), filerwindow->x(), filerwindow->y(), true, "Master-filer");
          filerwindow->hide();
          delete filerwindow;
      }

      saveWin(synth, masterwindow->w(), masterwindow->h(), masterwindow->x(), masterwindow->y(), true, "Master");

      masterwindow->hide();
      delete masterwindow;} {}
  }
  Function {Init()} {} {
    code {//
      current_ID = anchor.get().synthID;
      synth = anchor.get().synth;
      assert(synth);
      file::createDir(file::configDir() + "/windows");
      panelType = 5;
      msgSeen = false;
      syseffSeen = false;
      partmax = synth->getRuntime().NumAvailableParts;
      microtonalui = new MicrotonalUI(&synth->microtonal, synth);
      bankui = new BankUI(synth);
      virkeyboard = new VirKeyboard(synth);
      configui = new ConfigUI(synth, current_ID);
      presetsui = new PresetsUI(synth);
      paramsui = new ParametersUI(synth);
      vectorui = new VectorUI(synth, bankui, paramsui);
      midilearnui = new MidiLearnUI(synth);
      yoshiLog = new ConsoleUI(synth);
      Fl_Tooltip::color(tooltip_back);
      Fl_Tooltip::textcolor(tooltip_text);
      make_window();
      partui->checkEngines();

      bool foundWindows = Showmaster();
      if (current_ID > 0)
          foundWindows = true; //  not relevant for later windows
      //std::cout << "Found windows " << int(foundWindows) << std::endl;
      loadWindowData();
      string starterror = "";
      if (synth->getIsLV2Plugin())
      {
          masterwindow->label(synth->getWindowTitle().c_str());
      }
      else
      {
          starterror = textMsgBuffer.fetch(0);
          setMasterLabel(synth->getRuntime().paramsLoad);
      }
      if (starterror.find("Could not") != std::string::npos)
          query("", "", "", starterror);
      microtonalui->microtonaluiwindow->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("Scales"), UNUSED, TOPLEVEL::windowTitle)).c_str());
      yoshiLog->logConsole->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("Console"), UNUSED, TOPLEVEL::windowTitle)).c_str());
      logenable = fetchData(0, CONFIG::control::reportsDestination, TOPLEVEL::section::config);
      if (!foundWindows)
      {
          // fake previously seen.
          saveWin(synth, 0, 0, masterwindow->x() + masterwindow->w() + 16, masterwindow->y(), true, "Midi-virtualkeyboard");
          virkeyboard->ShowKbd();
          panelwindow->resize(masterwindow->x(), masterwindow->y(), PANEL_SINGLE_X, PANEL_SINGLE_Y);
          saveWin(synth, panelwindow->w(), panelwindow->h(), panelwindow->x(), panelwindow->y(), panelType, "Mixer");
          string msg = "As this is a first time start, please check 'Yoshimi->Settings' then save and restart. More information can be found in the manual.";
          setmessage(UNUSED, true, msg, "Close");
      }
      else if (synth->getRuntime().oldConfig)
      {
          string msg;
          msg = "Existing config older than V " + to_string(MIN_CONFIG_MAJOR) + "." + to_string(MIN_CONFIG_MINOR) + " \\nCheck settings, save and restart.";
          setmessage(UNUSED, true, msg, "Close");
      }
      else if (current_ID == 0 && synth->getRuntime().banksChecked == false)
      {
          string msg = "Default banks have been copied to {user}.local/share/yoshimi/found \\nAdd these to the bank roots window?";
          setmessage(TOPLEVEL::msgResponse::refreshBankDefaults, true, msg, "Ask Later", "No", "Yes");} {}} {}
  }
  Function {Showmaster()} {return_type bool
  } {
    code {//
    int fetchW, fetchH, fetchX, fetchY, fetchO;
    loadWin(synth, fetchW, fetchH, fetchX, fetchY, fetchO, "Master");
    if (fetchW < mainDW || fetchH < mainDH)
    {
        fetchW = mainDW;
        fetchH = mainDH;
    }
    checkSane(fetchX, fetchY, fetchW, fetchH, mainDW, mainDH);

    masterwindow->resize(fetchX, fetchY, fetchW, fetchH);
    masterwindow->show();
    lastmainW = 0;
    mainRtext();

    return (fetchO != 0);} {}
  }
  Function {make_window()} {} {
    Fl_Window masterwindow {
      label {Yoshimi meets ZynAddSubFX}
      callback {//
            bool close = true;
            bool force = Fl::event_state(FL_CTRL);
            /*if (!force && synth->getRuntime().configChanged)
            {
                int r = query("!", "!", "!", "Parameters Changed.\\nSave on exit?");
                switch (r)
                {
                    case 3:
                        synth->getRuntime().configChanged = false;
                        // this seems backwards but it *always* saves.
                        // seeing configChanged makes it reload the old settings first.
                        break;
                    case 2:
                        break;
                    default:
                        close = false;
                        break;
                }
            }*/
            if (close)
            {
                if (force)
                    firstSynth->getRuntime().exitType = FORCED_EXIT;
                    /*
                    * The above line shouldn't be necessary!
                    * It works fine on jack but fails on ALSA.
                    * My best guess is that ALSA shuts down so quickly
                    * that one of the ringbuffers carrying the command
                    * is deleted before it can be read.
                    */
                    //send_data(0, TOPLEVEL::control::forceExit, 0, UNUSED);

                synth->guiClosed(true);
            }}
      xywh {123 76 385 500} type Double labelfont 13 labelsize 12 hide resizable
      code0 {mainDW = 385; mainDH = 470;}
      code1 {masterwindow->size_range(394, 500, 0, 0, 0, 0, 1);}
    } {
      Fl_Box keyHandle {
        label keyhandler
        xywh {0 0 385 500} box FLAT_BOX
        code0 {o->init(synth);}
        class KeyHandle
      }
      Fl_Box topcontrols {
        xywh {271 28 111 115} box ENGRAVED_FRAME
      }
      Fl_Menu_Bar mastermenu {
        callback {//
    int found = o->value();
    //std::cout << "switch found " << found << std::endl;
    switch (found)
        {
        case 1: // about
            {
            int X, Y, W, H, O;
            loadWin(synth, W, H, X, Y, O, "Master-about");
            if (W < aboutDW || H < aboutDH)
            {
                W = aboutDW;
                H = aboutDH;
            }
            checkSane(X, Y, W, H, aboutDW, aboutDH);
            aboutwindow->resize(X, Y, W, H);
            aboutwindow->show();
            }
            break;
        case 2: // new instance
            if (synth->getIsLV2Plugin())
            {
                query("", "", "", "Start new instances from host");
                return;
            }
            if (current_ID != 0)
            {
                query("", "", "", "Only main instance can start others");
                return;
            }
            startInstance();
            break;
        case 3: // settings
            configui->Show(synth);
            break;
        case 4: // reports
            if (logenable)
                yoshiLog->Show(synth);
            else
                alert(synth, "Logging configured for std::cout");
            break;
        case 5: // manual
            send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::openManual, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
            break;
        case 6: // exit
            masterwindow->do_callback();
            break;

        case 7: // section instruments
            break;
        case 8: // section instruments
            break;
        case 9: // show
            bankui->Show();
            break;
        case 10: // load
            {
            string filename = setfiler("", "", false, TOPLEVEL::XML::Instrument);
            if (!filename.empty())
                do_load_instrument(filename);
            }
            break;
        case 11: // save
            {
            /*
            * Instruments are an exception for saving as we always want
            * to offer the INTERNAL name first rather than a possibly
            * confusing external filename.
            */
            string newname = synth->part[activePart]->Pname;
            if (newname == DEFAULT_NAME)
            {
                query("", "", "", "Nothing to save!");
                return;
            }
            if (synth->part[activePart]->info.Ptype == 0)
            {
                if (choice(synth, "", "Save", "Cancel", "Please set instrument type before saving.\\nCopyright info also recommended.") != 2)
                    return;
            }
            string filename = setfiler("", newname, true, TOPLEVEL::XML::Instrument);
            if (!filename.empty())
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedInstrument, activePart, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(string(filename)));
            }
            break;
        case 12: // recent
            {
            int xpos = masterwindow->x() + (masterwindow->w() * 0.15f);
            if (xpos + paramsui->Recent->w() > masterwindow->x() + masterwindow->w())
                xpos = masterwindow->x() + masterwindow->w() - paramsui->Recent->w();
            paramsui->Recent->position(xpos,masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::Instrument);
            }
            break;
        case 13: // clear
        if (!fetchData(0, PART::control::enable, activePart))
            {
                alert(synth, "Active part disabled");
                return;
            }
            partui->instrumentReset->do_callback();
            break;
        case 14: // search
        if (!fetchData(0, PART::control::enable, activePart))
            {
                alert(synth, "Active part disabled");
                return;
            }
            bankui->ShowSearch();
            break;

        case 15: // section parameters
            break;
        case 16: // section parameters
            break;
        case 17: // show
            bankui->Showbank();
            break;
        case 18: // load
             do_load_master("");
            break;
        case 19: // save
            {
            bool valid = false;
            for (int npart = 0; npart < NUM_MIDI_PARTS; npart ++)
                if (synth->part[npart]->Pname != DEFAULT_NAME)
                {
                    valid = true;
                    npart = NUM_MIDI_PARTS;
                }
            if (valid)
                do_save_master();
            else
                query("", "", "", "Nothing to save!");
            }
            break;
        case 20: // recent
            {
            int xpos = masterwindow->x() + (masterwindow->w() * 0.35f);
            if (xpos + paramsui->Recent->w() > masterwindow->x() + masterwindow->w())
                xpos = masterwindow->x() + masterwindow->w() - paramsui->Recent->w();
            paramsui->Recent->position(xpos,masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::Patch);
            }
            break;

        case 21: // section paths
            break;
        case 22: // section paths
            break;
        case 23: // root dir
            bankui->ShowRoot();
            break;
        case 24: // preset dir
            configui->Showpresets(synth);
            break;

        case 25: // section state
            break;
        case 26: // section state
            break;

        case 27: // load
            {
            // for Alessandro
            string filename = setfiler("", "", false, TOPLEVEL::XML::State);
            if (!filename.empty())
                setState(filename);
            else
                refresh_master_ui(0x80 | (textMsgBuffer.push(" ") << 8));
            }
            break;
        case 28: // save
            {
            // for Alessandro
            string filename = setfiler("", "", true, TOPLEVEL::XML::State);
            if (!filename.empty())

                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));
            }
            break;
        case 29: // default
            {
            string name = synth->getRuntime().defaultStateName;
            name += ("-" + to_string(current_ID));
            send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(name + ".state"));

            }
            break;
        case 30: // recent
            {
            int xpos = masterwindow->x() + (masterwindow->w() * 0.616f);
            if (xpos + paramsui->Recent->w() > masterwindow->x() + masterwindow->w())
                xpos = masterwindow->x() + masterwindow->w() - paramsui->Recent->w();
            paramsui->Recent->position(xpos,masterwindow->y()+20);

            paramsui->Show(TOPLEVEL::XML::State);
            }
            break;

        case 31: // section scales
            break;
        case 32: // section scales
            break;
        case 33: // show
            microtonalui->showScales();
            break;
        case 34: // load
            {
            filename = setfiler("", "", false, TOPLEVEL::XML::Scale);
            if (!filename.empty())
                do_load_scale(string(filename));
            }
            break;
        case 35: // save
            {
            string filename = setfiler("", "", true, TOPLEVEL::XML::Scale);
            if (!filename.empty())
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedScale, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));
            }
            break;
        case 36: // recent
            paramsui->Recent->position(masterwindow->x() + masterwindow->w() - paramsui->Recent->w(), masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::Scale);
            break;
        case 37: // clear
            if (query("", "Yes", "No", "Set scales to the defaults?") > 1)
            {
                synth->microtonal.defaults();
                synth->setAllPartMaps();
                if (NULL != microtonalui)
                    delete microtonalui;
                microtonalui = new MicrotonalUI(&synth->microtonal, synth);
                send_data(TOPLEVEL::action::forceUpdate, SCALES::control::clearAll, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::scales);
            }
            break;
      }}
        xywh {-7 0 395 25} labelsize 12 labelcolor 64 textsize 12 textcolor 64
        code0 {//
        o->add("&Yoshimi  /&About...");
        o->add("&Yoshimi  /&New Instance");
        o->add("&Yoshimi  /&Settings...");
        o->add("&Yoshimi  /&Reports");
        o->add("&Yoshimi  /&View Manual");
        o->add("&Yoshimi  /&Exit");

        o->add("&Instrument  /S&how Stored...");
        o->add("&Instrument  /&Load External...");
        o->add("&Instrument  /&Save External...");
        o->add("&Instrument  /&Recent Instruments...");
        o->add("&Instrument  /&Clear");
        o->add("&Instrument  /S&earch...");

        o->add("&PatchSet  /&S&how Patch Banks...");
        o->add("&PatchSet  /&Load External...");
        o->add("&PatchSet  /&Save External...");
        o->add("&PatchSet  /&Recent sets...");

        o->add("Pat&h  /&Bank Root Dirs...");
        o->add("Pat&h  /&Preset Dirs...");

        o->add("&State  /&Load...");
        o->add("&State  /&Save...");
        o->add("&State  /&Save As default");
        o->add("&State  /&Recent States");

        o->add("S&cale/S&how Settings...");
        o->add("S&cale/&Load...");
        o->add("S&cale/&Save...");
        o->add("S&cale/&Recent Scales...");}
      } {}
      Fl_Group MasterControls {
        label {Master  }
        xywh {3 24 380 121} labeltype NO_LABEL labelsize 11 labelcolor 96 align 22
      } {
        Fl_Dial globalfinedetune {
          label Detune
          callback {//
          o->selection_color(setKnob(o->value(),64));
          send_data(TOPLEVEL::action::lowPrio, MAIN::control::detune, o->value(), 0, TOPLEVEL::section::main);}
          tooltip {Global Fine Detune} xywh {280 32 40 40} box ROUND_UP_BOX color 29 labelsize 10 labelcolor 64 maximum 127 value 64
          code0 {o->setValueType(VC_GlobalFineDetune);}
          code1 {o->value(synth->microtonal.Pglobalfinedetune);}
          code2 {o->selection_color(setKnob(o->value(),64));}
          class WidgetPDial
        }
        Fl_Button mainreset {
          label Reset
          callback {//
          bool wasCtrl = (Fl::event_state(FL_CTRL) != 0);
          if (query("", "Yes", "No", "Set *ALL* dynamic values to their defaults?") > 1)
          {
              if (wasCtrl || (Fl::event_state(FL_CTRL) != 0))
                  send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::masterResetAndMlearn, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
              else
                  send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::masterReset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}}
          tooltip {Clear all dynamic settings
(+Ctrl includes MIDI-learn)} xywh {7 60 68 24} box PLASTIC_UP_BOX color 228 labelfont 1 labelsize 11 labelcolor 64 align 16
        }
        Fl_Button mainstop {
          label {Stop!}
          callback {//
    send_data(TOPLEVEL::action::muteAndLoop, MAIN::control::stopSound, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
          tooltip {Cease all sound immediately!} xywh {7 30 68 24} box PLASTIC_UP_BOX color 89 labelfont 1 labelsize 11 labelcolor 64 align 16
        }
        Fl_Dial mastervolumedial {
          label Volume
          callback {//
          o->selection_color(setKnob(o->value(),90));
          send_data(0, MAIN::control::volume, o->value(), 0, TOPLEVEL::section::main);}
          tooltip {Master Volume} xywh {331 32 40 40} box ROUND_UP_BOX color 29 labelsize 10 labelcolor 64 maximum 127
          code0 {o->setValueType(VC_MasterVolume);}
          code1 {o->value(synth->Pvolume);}
          code2 {o->selection_color(setKnob(o->value(),90));}
          class WidgetPDial
        }
        Fl_Button mainvirtkeyb {
          label {Virtual Keyboard}
          callback {//
          virkeyboard->ShowKbd();}
          tooltip {Virtual Keyboard} xywh {83 60 106 24} box GTK_THIN_UP_BOX color 198 labelsize 11 labelcolor 64
        }
        Fl_Button mixerpanel {
          label {Mixer Panel}
          callback {//
          if(panelwindow->visible())
              return;
          panelType &= 3;
          updatepanel();
          panelwindow->show();}
          tooltip {Mixer Panel Window} xywh {83 30 106 24} box GTK_THIN_UP_BOX color 198 labelsize 11 labelcolor 64
        }
        Fl_Button mainmidilearn {
          label {Midi Learn}
          callback {//
                midilearnui->showLearn();}
          tooltip {Message Log} xywh {83 90 106 24} box GTK_THIN_UP_BOX color 198 labelsize 11 labelcolor 64
        }
        Fl_Button vectors {
          label Vectors
          callback {//
          vectorui->Show(synth);}
          tooltip {Vector Setup Window} xywh {197 30 68 24} box GTK_THIN_UP_BOX color 198 labelsize 11 labelcolor 64
        }
        Fl_Button undo {
          label Undo
          callback {//
        send_data(0, MAIN::control::undo,  0, TOPLEVEL::type::Integer, TOPLEVEL::section::undoMark);}
          tooltip {Revert last change} xywh {197 60 68 24} box PLASTIC_UP_BOX color 228 labelsize 11 labelcolor 64
        }
        Fl_Button redo {
          label Redo
          callback {//
        send_data(0, MAIN::control::redo,  0, TOPLEVEL::type::Integer, TOPLEVEL::section::undoMark);}
          tooltip {Re-apply last change} xywh {197 90 68 24} box PLASTIC_UP_BOX color 228 labelsize 11 labelcolor 64
        }
      }
      Fl_Tabs sysinsgroup {
        label {System/Insert}
        callback {//
        if (o->value() == SystemEffectsGrp)
            showSysEfxUI();
        else if (o->value() == InsertionEffectsGrp)
            showInsEfxUI();}
        xywh {3 118 379 68} box PLASTIC_UP_BOX color 44 selection_color 223 labeltype NO_LABEL labelsize 12 labelcolor 64 align 5
      } {
        Fl_Group SystemEffectsGrp {
          label {  System Effects  }
          xywh {3 146 379 40} color 223 selection_color 31 labelfont 1 labelsize 12 labelcolor 64 align 4
        } {
          Fl_Spinner syseffnocounter {
            label Effect
            callback {//
                int effNum = o->value() - 1;
                send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectNumber, effNum, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, effNum);}
            xywh {40 156 36 20} labeltype NO_LABEL labelsize 11 labelcolor 64 align 0 maximum 4 textfont 1 textsize 11 textcolor 64
            code0 {o->range(1, NUM_SYS_EFX);}
            code1 {o->value(1);}
            class WidgetSpinner
          }
          Fl_Choice sysefftype {
            label Type
            callback {//
                uchar effType = o->value();
                uchar effNum = syseffectui->effNum();
                send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectType, effType, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, effNum);}
            xywh {120 156 96 20} down_box BORDER_BOX labeltype NO_LABEL labelsize 11 labelcolor 64 align 16 textfont 1 textsize 11 textcolor 64
            code0 {o->add("No Effect");o->add("Reverb");o->add("Echo");o->add("Chorus");o->add("Phaser");o->add("AlienWah");o->add("Distortion");o->add("EQ");o->add("DynFilter");}
            code1 {o->value(0); // initially disabled}
          } {}
          Fl_Check_Button SysEffOn {
            label On
            callback {//
                if (o->value())
                {
                    sysefftype->activate();
                    sysCopy->activate();
                    sysPaste->activate();
                }
                else
                {
                    sysefftype->deactivate();
                    sysCopy->deactivate();
                    sysPaste->deactivate();
                }
                uchar effNum = syseffectui->effNum();
                send_data(0, EFFECT::sysIns::effectEnable, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, effNum);}
            xywh {247 156 20 20} down_box DOWN_BOX value 1 selection_color 64 labelfont 3 labelcolor 226 align 4
            class Fl_Check_Button2
          }
          Fl_Button sysEffSend {
            label {Send to}
            callback {showSysEffSends();}
            xywh {275 156 62 20} box GTK_THIN_UP_BOX color 221 labelfont 1 labelsize 11 labelcolor 64
          }
          Fl_Button sysCopy {
            label C
            callback {//
                uchar effNum = syseffectui->effNum();
                synth->getGuiMaster()->getPresetsUi()->Ucopy(TOPLEVEL::section::systemEffects, 16, effNum);}
            xywh {350 152 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 197
          }
          Fl_Button sysPaste {
            label P
            callback {//
                uchar effNum = syseffectui->effNum();
                synth->getGuiMaster()->getPresetsUi()->Upaste(TOPLEVEL::section::systemEffects, 16, effNum);}
            xywh {350 167 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 197
          }
        }
        Fl_Group InsertionEffectsGrp {
          label { Insertion Effects }
          xywh {3 146 379 40} color 223 selection_color 31 labelfont 1 labelsize 12 labelcolor 64 align 4 hide
        } {
          Fl_Spinner inseffnocounter {
            label Effect
            callback {//
                int effNum = o->value() - 1;
                send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectNumber, effNum, TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, effNum);}
            xywh {40 156 36 20} labeltype NO_LABEL labelsize 11 labelcolor 64 align 20 maximum 8 textfont 1 textsize 11 textcolor 64
            code0 {o->range(1, NUM_INS_EFX);}
            code1 {o->value(1);}
            class WidgetSpinner
          }
          Fl_Choice insefftype {
            label Type
            callback {//
                uchar effType = o->value();
                uchar effNum = inseffectui->effNum();
                send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectType, effType, TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, effNum);}
            xywh {120 156 96 20} down_box BORDER_BOX labeltype NO_LABEL labelsize 11 labelcolor 64 align 0 textfont 1 textsize 11 textcolor 64
            code0 {o->add("No Effect");o->add("Reverb");o->add("Echo");o->add("Chorus");o->add("Phaser");o->add("AlienWah");o->add("Distortion");o->add("EQ");o->add("DynFilter");}
            code1 {o->value(0);}
            code2 {o->deactivate(); // initially deactivated}
          } {}
          Fl_Choice inseffpart {
            label {To }
            callback {//
                int routing = o->value() - 2;
                uchar effNum = inseffectui->effNum();
                send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectDestination, routing, TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, effNum);}
            xywh {242 156 96 20} down_box BORDER_BOX labelfont 1 labelsize 11 labelcolor 64 textfont 1 textsize 11 textcolor 64
            code0 {setinspartlist();}
            code3 {o->value(1); // initially deactivated}
          } {}
          Fl_Button insCopy {
            label C
            callback {//
                uchar effNum = inseffectui->effNum();
                synth->getGuiMaster()->getPresetsUi()->Ucopy(TOPLEVEL::section::insertEffects, 16, effNum);}
            xywh {350 152 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 197
          }
          Fl_Button insPaste {
            label P
            callback {//
                uchar effNum = inseffectui->effNum();
                synth->getGuiMaster()->getPresetsUi()->Upaste(TOPLEVEL::section::insertEffects, 16, effNum);}
            xywh {350 167 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 197
          }
        }
      }
      Fl_Group syseffectuigroup {
        xywh {3 188 379 95} box FLAT_BOX color 48 labeltype NO_LABEL labelcolor 64
        code0 {o->show();}
      } {
        Fl_Group syseffectui {
          xywh {3 188 379 95} labeltype NO_LABEL labelcolor 64
          code0 {o->init(synth, anchor.get().sysEffectParam, anchor.get().sysEffectEQ, TOPLEVEL::section::systemEffects);
                 o->activate();
                 o->show();}
          class EffUI
        } {}
      }
      Fl_Group inseffectuigroup {
        xywh {3 188 379 95} box FLAT_BOX color 48 labelcolor 64
        code0 {o->hide();}
      } {
        Fl_Group inseffectui {
          xywh {3 188 379 95} color 52 labelcolor 64
          code0 {o->init(synth, anchor.get().insEffectParam, anchor.get().insEffectEQ, TOPLEVEL::section::insertEffects);
                 o->hide();}
          code1 {o->deactivate(); // initially deactivated}
          class EffUI
        } {}
      }
      Fl_Group partuigroup {open
        xywh {3 285 379 178} box ENGRAVED_FRAME
      } {
        Fl_Group partui {
          xywh {3 285 379 172} color 47
          code0 {partui->init(synth->part[npart], npart, bankui);}
          class PartUI
        } {}
        Fl_Group partControls {open
          xywh {3 286 378 175}
        } {
          Fl_Dial partVol {
            label Volume
            callback {//
            if (npart >= panelgroup && npart < (panelgroup + NUM_MIDI_CHANNELS))
                o->selection_color(setKnob(o->value(),96));
            setPanelPartVolWidget(npart % NUM_MIDI_CHANNELS, o->value());

            send_data(0, PART::control::volume, o->value(), TOPLEVEL::type::Integer, npart);}
            xywh {340 327 32 32} labelsize 10 labelcolor 64 maximum 127 step 1
            code0 {o->value(fetchData(0, PART::control::volume, npart));}
            code1 {o->setValueType(VC_PartVolume);}
            code2 {o->selection_color(setKnob(o->value(),96));}
            class WidgetPDial
          }
          Fl_Dial partPan {
            label Panning
            callback {//
            o->selection_color(setKnob(o->value(),64));

            send_data(TOPLEVEL::action::forceUpdate, PART::control::panning, o->value(), TOPLEVEL::type::Integer, npart);}
            xywh {292 327 32 32} labelsize 10 labelcolor 64 maximum 127 step 1
            code0 {o->value(fetchData(0, PART::control::panning, npart));}
            code1 {o->setValueType(VC_PanningStd);}
            code2 {o->selection_color(setKnob(o->value(),64));}
            class WidgetPDial
          }
          Fl_Dial partVelOffset {
            label {Vel.Offs}
            callback {//
                o->selection_color(setKnob(o->value(),64));
                send_data(0, PART::control::velocityOffset, o->value(), TOPLEVEL::type::Integer, npart);}
            xywh {244 327 32 32} labelsize 10 labelcolor 64 maximum 127 step 1
            code0 {o->value(fetchData(0, PART::control::velocityOffset, npart));}
            code1 {o->selection_color(setKnob(o->value(),64));}
            class WidgetPDial
          }
          Fl_Dial partVelSense {
            label {Vel.Sense}
            callback {//
                o->selection_color(setKnob(o->value(),64));
                send_data(0, PART::control::velocitySense, o->value(), TOPLEVEL::type::Integer, npart);}
            xywh {196 327 32 32} labelsize 10 labelcolor 64 maximum 127 step 1
            code0 {o->value(fetchData(0, PART::control::velocitySense, npart));}
            code1 {o->setValueType(VC_AmpVelocitySense);}
            code2 {o->selection_color(setKnob(o->value(),64));}
            class WidgetPDial
          }
          Fl_Group instrumentGroup {
            xywh {136 291 195 25} box GTK_THIN_UP_BOX color 198
          } {
            Fl_Box instrumentaddbox {
              xywh {140 296 60 15} box FLAT_BOX
            }
            Fl_Box instrumentsubbox {
              xywh {200 296 65 15} box FLAT_BOX
            }
            Fl_Box instrumentpadbox {
              xywh {264 296 63 15} box FLAT_BOX
            }
            Fl_Box instrumentlabel {
              label {Simple Sound}
              xywh {139 295 187 16} selection_color 64 labelsize 12 labelcolor 64 align 16
            }
            Fl_Box instrumentFrame {
              xywh {140 296 187 15} box THIN_DOWN_FRAME labelcolor 49
            }
            Fl_Button buttontop {
              callback {//
          int event = Fl::event_button();
          if (event == FL_LEFT_MOUSE)
          {
              synth->getGuiMaster()->activePart = npart;
              bankui->Show();
          }
          else if (event == FL_RIGHT_MOUSE)
          {
              string name = input_text(synth, "Instrument name:", synth->part[activePart]->Pname);
              if (name == DEFAULT_NAME)
                  alert(synth, "Can't use name of default sound");
              else if (name != synth->part[activePart]->Pname)
              {
                  unsigned char id = textMsgBuffer.push(name);
                  send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, PART::control::instrumentName, 0, TOPLEVEL::type::Integer, activePart, UNUSED, UNUSED, UNUSED, id);
              }
          }}
              tooltip {Left mouse button: choose/save/.. from/to bank, Right button: instrument name} xywh {136 291 195 25} box NO_BOX selection_color 64 labeltype NO_LABEL labelsize 12 labelcolor 64 align 16
            }
          }
          Fl_Spinner partMidiCh {
            label Midi
            callback {//
          int tmp = int(o->value()) -1;
          if (tmp >= NUM_MIDI_CHANNELS)
          {
              tmp &= (NUM_MIDI_CHANNELS - 1);
              o->value(tmp +1);
          }
          o->textcolor(gen_text);
          if (npart >= panelgroup && npart < (panelgroup + NUM_MIDI_CHANNELS))
              setPanelPartMidiWidget(npart % NUM_MIDI_CHANNELS, tmp);

          send_data(0, PART::control::midiChannel, tmp, TOPLEVEL::type::Integer, npart);}
            tooltip {MIDI channel for this part} xywh {34 350 40 19} color 7 labelsize 11 labelcolor 64 maximum 16 textsize 11 textcolor 64
            code0 {int num = fetchData(0,  PART::control::midiChannel, npart); o->value(num + 1); if (num < NUM_MIDI_CHANNELS) o->textcolor(gen_text); else o->textcolor(gen_opp_text);}
            class WidgetSpinner
          }
          Fl_Button partEdit {
            label Edit
            callback {//
       /* bool divert = true;
        if (lastkey >= 49 && lastkey <= 56)
        { // not working yet :(
            int voiceNum = lastkey - 49;
            if (Fl::event_button() == 3)
            {
                send_data(0, PART::control::enable, 1, TOPLEVEL::type::Integer, UNUSED, 0);
                adsynenabledcheck->value(1);
                send_data(TOPLEVEL::action::forceUpdate, PART::control::volumeEnable, voiceNum, TOPLEVEL::type::Integer);
                //synth->getGuiMaster()->partui->adnoteui->advoice->nvoice = voiceNum;
                //synth->getGuiMaster()->partui->adnoteui->advoice->voiceonbutton->value(1);
            }
            if (adsynenabledcheck->value() == 1)
            {
                ;
            }
            lastkey = -1;
        }
        switch(lastkey)
        {
            case 97: // a
                if (Fl::event_button() == 3)
                {
                    send_data(0, PART::control::enableAdd, 1, TOPLEVEL::type::Integer, UNUSED, 0);
                    adsynenabledcheck->value(1);
                }

                lastkey = -1;
                if (adsynenabledcheck->value() == 1)
                {
                    showparameters(0,0);
                    partui->checkEngines();
                    seteditname();
                }
                else
                    divert = false;
                break;
            case 115: // s
                if (Fl::event_button() == 3)
                {
                    send_data(0, PART::control::enableSub, 1, TOPLEVEL::type::Integer, UNUSED, 1);
                    subsynenabledcheck->value(1);
                }
                lastkey = -1;
                if (subsynenabledcheck->value() == 1)
                {
                showparameters(0,1);
                partui->checkEngines();
                seteditname();
                }
                else
                    divert = false;
                break;
            case 100: // d
            case 112: // p
                if (Fl::event_button() == 3)
                {
                    send_data(0, PART::control::enablePad, 1, TOPLEVEL::type::Integer, UNUSED, 2);
                    padsynenabledcheck->value(1);
                }
                lastkey = -1;
                if (padsynenabledcheck->value() == 1)
                {
                    showparameters(0,2);
                    partui->checkEngines();
                    seteditname();
                    lastkey = -1;
                }
                else
                    divert = false;
                break;
            case 107: // k
                lastkey = -1;
                Showkit();
                break;
            case 101: // e
                lastkey = -1;
                Showefx();
                break;
            default:
                divert = false;
                break;
        }
        */
        //if (!divert)
        //{
            //lastkey = -1;
            partui->Showedit();
       // }}
            tooltip {View/change instrument sound and details} xywh {334 291 42 25} box GTK_THIN_UP_BOX color 198 labelfont 1 labelsize 12 labelcolor 64
          }
          Fl_Button partControllers {
            label Controllers
            callback {//
          partui->Showctl();}
            tooltip {MIDI Controller range settings} xywh {8 373 86 22} box GTK_THIN_UP_BOX color 198 labelsize 12 labelcolor 64
          }
          Fl_Button partMidiCCs {
            label {Midi CCs}
            callback {//
          partui->Showctlmidi();}
            tooltip {Emulates common MIDI CCs} xywh {100 373 60 22} box GTK_THIN_UP_BOX color 198 labelsize 12 labelcolor 64
          }
          Fl_Box modepatch {
            label Mode
            xywh {155 328 32 17} box FLAT_BOX labelsize 11 labelcolor 64
          }
          Fl_Choice partKeymode {
            callback {//
                updateModepatch(o->value() > 1 && partui->drumMode->value() != 0);
                send_data(0, PART::control::keyMode, o->value(), TOPLEVEL::type::Integer, npart);}
            tooltip {Poly, Mono or Legato mode} xywh {82 327 68 19} down_box BORDER_BOX labelsize 11 labelcolor 64 align 8 textfont 1 textsize 11 textcolor 64
            code0 {o->add("Poly");o->add("Mono");o->add("Legato");}
            code1 {int tmp = synth->ReadPartKeyMode(npart); if (tmp > 1) o->value(2); else o->value(tmp);}
            code3 {o->value(fetchData(0, PART::control::keyMode, npart));}
          } {}
          Fl_Check_Button partPortamento {
            label Portamento
            callback {//
          send_data(0, PART::control::portamento, o->value(), TOPLEVEL::type::Integer, npart);}
            tooltip {Enable/Disable the portamento} xywh {84 351 14 18} down_box DOWN_BOX labelfont 3 labelsize 11 labelcolor 226 align 8
            code0 {o->value(fetchData(0, PART::control::portamento, npart));}
            class Fl_Check_Button2
          }
          Fl_Spinner minKeyCount {
            label {Min Note}
            callback {//
          int tmp = o->value();
          int other = maxKeyCount->value();
          if (tmp > other)
          {
              tmp = other;
              o->value(tmp);
          }

          send_data(0, PART::control::minNote, tmp, TOPLEVEL::type::Integer, npart);}
            tooltip {Minimum note the part receives} xywh {59 402 42 20} labelsize 10 labelcolor 64 minimum 0 maximum 127 textsize 11 textcolor 64
            code0 {o->value(fetchData(0, PART::control::minNote, npart));}
            class WidgetSpinner
          }
          Fl_Spinner maxKeyCount {
            label {Max Note}
            callback {//
          int tmp = o->value();
          int other = minKeyCount->value();
          if (tmp < other)
          {
              tmp = other;
              o->value(tmp);
          }

          send_data(0, PART::control::maxNote, tmp, TOPLEVEL::type::Integer, npart);}
            tooltip {Maximum note the part receives} xywh {59 434 42 20} labelsize 10 labelcolor 64 minimum 0 maximum 127 textsize 11 textcolor 64
            code0 {o->value(fetchData(0, PART::control::maxNote, npart));}
            class WidgetSpinner
          }
          Fl_Button setMinToLast {
            label Set
            callback {//
          int lastnote = synth->part[npart]->getLastNote();
          if (lastnote >= 0)
          {
              minKeyCount->value(lastnote);
              send_data(0, PART::control::minToLastKey, 1, TOPLEVEL::type::Integer, npart);
          }}
            tooltip {Set minimum note to the last note played} xywh {105 403 30 16} box PLASTIC_UP_BOX color 228 labelsize 10 labelcolor 64
          }
          Fl_Button setNormal {
            label R
            callback {//
          minKeyCount->value(0);
          maxKeyCount->value(127);
          send_data(0, PART::control::resetMinMaxKey, 1, TOPLEVEL::type::Integer, npart);}
            tooltip {Reset the minimum key to 0 and maximum key to 127} xywh {105 421 30 16} box PLASTIC_UP_BOX color 228 labelfont 1 labelsize 11 labelcolor 64
          }
          Fl_Button setMaxToLast {
            label Set
            callback {//
          int lastnote = synth->part[npart]->getLastNote();
          if (lastnote >= 0)
          {
              maxKeyCount->value(lastnote);
              send_data(0, PART::control::maxToLastKey, 1, TOPLEVEL::type::Integer, npart);
          }}
            tooltip {Set maximum note to the last note played} xywh {105 439 30 16} box PLASTIC_UP_BOX color 228 labelsize 10 labelcolor 64
          }
          Fl_Spinner partKeyShift {
            label {Key Shift}
            callback {//
          send_data(TOPLEVEL::action::lowPrio, PART::control::keyShift, o->value(), TOPLEVEL::type::Integer, npart);}
            xywh {195 403 38 20} labelsize 10 labelcolor 64 minimum -36 maximum 36 textsize 11 textcolor 64
            code0 {o->range(MIN_KEY_SHIFT, MAX_KEY_SHIFT);}
            code1 {o->value(fetchData(0, PART::control::keyShift, npart));}
            class WidgetSpinner
          }
          Fl_Spinner partKeyLimit {
            label {Key Limit}
            callback {//
          send_data(0, PART::control::maxNotes, o->value(), TOPLEVEL::type::Integer, npart);}
            tooltip {Maximum keys for this part} xywh {195 435 38 20} labelsize 10 labelcolor 64 value 20 textsize 11 textcolor 64
            code0 {o->range(1, POLYPHONY); // enough for one part!}
            code1 {o->value(fetchData(0, PART::control::maxNotes, npart));}
            class WidgetSpinner
          }
          Fl_Group sysEffBox {
            xywh {240 400 134 58} box ENGRAVED_FRAME labelcolor 64
          } {
            Fl_Text_Display sysEffName {
              label {Send to System Effect}
              xywh {255 440 103 1} box NO_BOX selection_color 64 labelsize 11 labelcolor 64 align 2 textcolor 64
            }
            Fl_Dial sysEff1 {
              label 1
              callback {//
    o->selection_color(setKnob(o->value(),0));
    send_data(TOPLEVEL::action::forceUpdate, PART::partToSystemEffect1, o->value(), TOPLEVEL::type::Integer, npart);}
              xywh {246 415 25 25} labelfont 1 labelsize 10 labelcolor 64 align 1 maximum 127 step 1
              code0 {o->value(fetchData(0, PART::control::partToSystemEffect1, npart));}
              code1 {o->setValueType(VC_percent127);}
              code2 {o->selection_color(setKnob(o->value(),0));}
              class WidgetPDial
            }
            Fl_Dial sysEff2 {
              label 2
              callback {//
    o->selection_color(setKnob(o->value(),0));
    send_data(TOPLEVEL::action::forceUpdate, PART::partToSystemEffect2, o->value(), TOPLEVEL::type::Integer, npart);}
              xywh {278 415 25 25} labelfont 1 labelsize 10 labelcolor 64 align 1 maximum 127 step 1
              code0 {o->value(fetchData(0, PART::control::partToSystemEffect2, npart));}
              code1 {o->setValueType(VC_percent127);}
              code2 {o->selection_color(setKnob(o->value(),0));}
              class WidgetPDial
            }
            Fl_Dial sysEff3 {
              label 3
              callback {//
    o->selection_color(setKnob(o->value(),0));
    send_data(TOPLEVEL::action::forceUpdate, PART::partToSystemEffect3, o->value(), TOPLEVEL::type::Integer, npart);}
              xywh {310 415 25 25} labelfont 1 labelsize 10 labelcolor 64 align 1 maximum 127 step 1
              code0 {o->value(fetchData(0, PART::control::partToSystemEffect3, npart));}
              code1 {o->setValueType(VC_percent127);}
              code2 {o->selection_color(setKnob(o->value(),0));}
              class WidgetPDial
            }
            Fl_Dial sysEff4 {
              label 4
              callback {//
    o->selection_color(setKnob(o->value(),0));
    send_data(TOPLEVEL::action::forceUpdate, PART::partToSystemEffect4, o->value(), TOPLEVEL::type::Integer, npart);}
              xywh {342 415 25 25} labelfont 1 labelsize 10 labelcolor 64 align 1 maximum 127 step 1
              code0 {o->value(fetchData(0, PART::control::partToSystemEffect4, npart));}
              code1 {o->setValueType(VC_percent127);}
              code2 {o->selection_color(setKnob(o->value(),0));}
              class WidgetPDial
            }
          }
        }
        Fl_Check_Button partEnable {
          label On
          callback {//;
        if (o->value() != 1)
            partControls->deactivate();
        else
            partControls->activate();

        if (npart >= panelgroup && npart < (panelgroup + NUM_MIDI_CHANNELS))
        {
            panellistitem[npart % NUM_MIDI_CHANNELS]->partenabled->value(o->value());
            if (o->value() != 1)
                panellistitem[npart % NUM_MIDI_CHANNELS]->panellistitemgroup->deactivate();
            else
                panellistitem[npart % NUM_MIDI_CHANNELS]->panellistitemgroup->activate();
        }

        send_data(0, PART::control::enable, o->value(), TOPLEVEL::type::Integer, npart);}
          xywh {58 326 20 20} down_box DOWN_BOX selection_color 64 labelcolor 64 align 4
          code0 {o->value(fetchData(0,  PART::control::enable, npart));}
          class Fl_Check_Button2
        }
      }
      Fl_Group {} {
        xywh {3 460 379 35} box DOWN_BOX color 43 labelsize 12
      } {
        Fl_Box vumeter {
          label {VU-Meter}
          xywh {3 461 379 34} color 48
          code0 {o->init(-1, synth);}
          class VUMeter
        }
        Fl_Button {} {
          callback {vumeter->init(-1, synth);}
          tooltip {Click here to clear VU peak reading and overload warning.} xywh {5 463 376 30} box NO_BOX labelcolor 64
        }
      }
      Fl_Button mastermono {
        label Stereo
        callback {//
        int tmp = 1 -  o->value();
        o->value(tmp);
        if (tmp == 0)
            o->label("Stereo");
        else
            o->label("Mono");
        send_data(0, MAIN::control::mono,  tmp, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Master Mono/Stereo switch} xywh {7 90 68 24} box PLASTIC_UP_BOX down_box PLASTIC_UP_BOX color 228 selection_color 89 labelfont 3 labelsize 11 labelcolor 226
        code0 {o->value(synth->masterMono);}
      }
      Fl_Spinner masterkeyshift {
        label {Key Shift}
        callback {//
        send_data(TOPLEVEL::action::lowPrio, MAIN::control::keyShift, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Shift pitch +/- N semitones} xywh {328 88 43 20} labelsize 10 labelcolor 64 minimum -36 maximum 36 textfont 1 textsize 12 textcolor 64
        code0 {o->range(MIN_KEY_SHIFT, MAX_KEY_SHIFT);o->step(1.0);}
        code1 {o->value(synth->Pkeyshift - 64);}
        class WidgetSpinner
      }
      Fl_Spinner bpmfallback {
        label {F. BPM}
        callback {//
        send_data(TOPLEVEL::action::forceUpdate, MAIN::control::bpmFallback, o->value(), 0, TOPLEVEL::section::main);}
        tooltip {Fallback BPM (Beats Per Minute). This is only used if the MIDI driver does not provide its own BPM information.} xywh {316 116 56 20} labelsize 10 labelcolor 64 minimum 0 maximum 0 value 120 textfont 1 textsize 12 textcolor 64
        code0 {o->range(BPM_FALLBACK_MIN, BPM_FALLBACK_MAX);}
        code1 {o->step(1.0); o->type(FL_FLOAT_INPUT);}
        code2 {setBpmFallbackValue(synth->PbpmFallback);}
        class WidgetSpinner
      }
      Fl_Spinner npartcounter {
        label Part
        callback {//
        int nval = o->value() - 1;
        activePart = nval;
        send_data(TOPLEVEL::action::forceUpdate, MAIN::control::partNumber, nval, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        xywh {36 292 40 23} labelsize 11 labelcolor 64 when 6 minimum 0 maximum 127 textsize 11 textcolor 64
        code0 {o->range(1.0, partmax);}
        code1 {o->value(synth->getRuntime().currentPart + 1);}
        code2 {bankui->init(o);}
        class WidgetSpinner
      }
      Fl_Spinner maxparts {
        label of
        callback {//
        int tmp = o->value();
        if (tmp == 48)
        {
            if (partmax == 32)
                tmp = 64;
            else
                tmp = 32;
        }
        send_data(TOPLEVEL::action::forceUpdate, MAIN::control::availableParts, tmp, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Set the number of available parts} xywh {93 292 40 23} labelsize 11 labelcolor 64 minimum 16 maximum 64 step 16 value 16 textsize 11 textcolor 64
        code0 {o->value(partmax);}
        class WidgetSpinner
      }
      Fl_Choice panning_law {
        label {Pan Law}
        callback {//
                       send_data(0, MAIN::control::panLawType, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Relative values when panned to extremes:
   Per side, Equivalent Mono} xywh {216 376 160 20} down_box BORDER_BOX labelsize 12 labelcolor 64 textfont 1 textsize 12 textcolor 64
        code0 {o->add("Cut: 0dB, -6dB");o->add("Default: +3dB, -3dB");o->add("Boost: +6dB, 0dB");}
        code1 {o->value(fetchData(0, MAIN::control::panLawType, TOPLEVEL::section::main));}
      } {}
      Fl_Group setInstance {
        xywh {82 57 193 60} box PLASTIC_UP_BOX color 223 hide
      } {
        Fl_Button {} {
          xywh {84 59 188 57} box NO_BOX
        }
        Fl_Text_Display InstBlurb {
          label {Accept next, or enter
Instance from 1 to 31}
          xywh {95 89 163 6} box NO_BOX labelsize 12
        }
        Fl_Button {} {
          callback {//}
          xywh {162 91 35 22} box FLAT_BOX down_box FLAT_BOX labelfont 1 labelsize 11
        }
        Fl_Button cancelInst {
          label Cancel
          callback {//}
          xywh {209 90 56 22} box PLASTIC_UP_BOX labelfont 1 labelsize 11
        }
        Fl_Button nextInst {
          label Next
          callback {//}
          xywh {93 90 56 22} box PLASTIC_UP_BOX labelfont 1 labelsize 11
        }
        Fl_Input valueInst {
          callback {//}
          xywh {162 90 37 22} textsize 11
        }
      }
      Fl_Box divider {
        xywh {18 320 350 2} box THIN_DOWN_FRAME
      }
    }
    comment {line spaces in boxes below are critical} {in_source in_header
    }
    Fl_Window aboutwindow {
      label {Yoshimi : About}
      xywh {46 64 365 290} type Double color 7 labelfont 13 labelsize 13 labelcolor 64 when 0 hide resizable
      code0 {aboutDW = 365; aboutDH = 290;}
      code1 {o->size_range(aboutDW,aboutDH, 0, 0, 0, 0, 1);}
    } {
      Fl_Group aboutFirst {
        xywh {0 0 365 290} color 7 labelcolor 64
      } {
        Fl_Box about1 {
          label {Yoshimi
meets
ZynAddSubFX}
          xywh {10 15 345 70} labelfont 9 labelsize 18 labelcolor 216 align 16 when 0
        }
        Fl_Box about2 {
          label {Copyright 2002-2009, Nasca O. Paul and others
Copyright 2009-2011, Alan Calvert
Copyright 2012-2013, Jeremy Jongepier and others
Copyright 2014-2023, Will Godfrey and others
LV2 plugin Copyright 2014, Andrew Deryabin
Splash Image Copyright 2017, Jesper Lloyd}
          xywh {25 90 315 91} labelfont 13 labelsize 11 labelcolor 64
        }
        Fl_Box about3 {
          label {This is free software, and comes with ABSOLUTELY NO
WARRANTY; you may redistribute it and/or modify it
under the terms of GPL version 2, or (at your option)
any later version.}
          xywh {10 190 340 53} labelsize 11 labelcolor 64
        }
        Fl_Box about4 {
          label { version}
          xywh {61 254 240 20} labelfont 1 labelsize 12 labelcolor 224
          code0 {//
            o->copy_label((string("Yoshimi version ")
                           + string(YOSHIMI_VERSION)).c_str());}
        }
        Fl_Button about5 {
          label more
          callback {//
                 contributors->show();
                 aboutFirst->hide();}
          tooltip {Yoshimi's little band of helpers} xywh {15 253 43 22} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 11 labelcolor 64
        }
      }
      Fl_Group contributors {
        xywh {5 5 355 280} box FLAT_BOX color 7 labelcolor 64 hide
      } {
        Fl_Box cont1 {
          label {Some people who have helped Yoshimi
 in various ways since
Alan Calvert started the project}
          xywh {12 8 340 57} labelfont 9 labelsize 15 labelcolor 224
        }
        Fl_Box cont2 {
          label {
          Chris Ahlstrom
          Kristian Amlie
          Jonathan Brickman
          Jeanette Claassen
          Rob Couto
          Andrew Deryabin
          Jörn Eichler
          Csaba Erdei
          James Fraser
          Will Godfrey
          Alexander Hirsch
          Jeremy Jongepier
          Iain King-Speir
          Tobias Kortkamp
          }
          xywh {25 70 155 200} labelsize 12 labelcolor 64
        }
        Fl_Box cont3 {
          label {
          Tito Latini
          Rainer Liffers
          Jesper Lloyd
          Lars Luthman
          Holger Marzen
          Lieven Moors
          Harry Nakos
          Iurie Nistor
          Stephen Parry
          Lorenzo Sutton
          Hermann Voßeler
          Nikita Zlobin


          }
          xywh {194 70 155 200} labelsize 12 labelcolor 64
        }
      }
      Fl_Button aboutClose {
        label Close
        callback {//
        aboutFirst->show();
        contributors->hide();
        aboutwindow->hide();}
        xywh {305 253 43 22} box THIN_UP_BOX color 196 labelfont 1 labelsize 11 labelcolor 64
      }
    }
    Fl_Window syseffsendwindow {
      label {Yoshimi : Sys Send}
      callback {syseffClose->do_callback();}
      xywh {534 25 120 245} type Double labelfont 13 labelsize 13 hide resizable
      code0 {syseffDW = 120; syseffDH = 245;}
      code1 {o->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("Sends"), UNUSED, TOPLEVEL::windowTitle)).c_str());}
      code2 {o->size_range(syseffDW, syseffDH, 0, 0, 0, 0, 1);}
    } {
      Fl_Group syseffgroup {
        xywh {4 46 112 160} box FLAT_BOX labelcolor 64
      } {}
      Fl_Button syseffClose {
        label Close
        callback {//
    saveWin(synth, syseffsendwindow->w(), syseffsendwindow->h(), syseffsendwindow->x(), syseffsendwindow->y(), false, "Master-systemeffectsend");
    syseffsendwindow->hide();
    syseffSeen = false;}
        xywh {20 216 80 25} box THIN_UP_BOX color 196 labelcolor 64
      }
      Fl_Box syseffname {
        label {Send output of system effect  to other system effects}
        xywh {5 5 110 35} labelsize 10 labelcolor 64 align 192
      }
      Fl_Dial syseff01 {
        label {1->2}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 1, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,0,TOPLEVEL::insert::systemEffectSend);}
        xywh {9 65 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
      Fl_Dial syseff02 {
        label {1->3}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 2, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,0,TOPLEVEL::insert::systemEffectSend);}
        xywh {45 65 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
      Fl_Dial syseff03 {
        label {1->4}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 3, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,0,TOPLEVEL::insert::systemEffectSend);}
        xywh {83 65 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
      Fl_Dial syseff12 {
        label {2->3}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 2, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,1,TOPLEVEL::insert::systemEffectSend);}
        xywh {45 118 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
      Fl_Dial syseff13 {
        label {2->4}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 3, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,1,TOPLEVEL::insert::systemEffectSend);}
        xywh {83 118 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
      Fl_Dial syseff23 {
        label {3->4}
        callback {//
        int val = lrint(o->value());
        if (Fl::event_button() == 3)
        {
            val = 0;
            o->value(val);
        }
        o->selection_color(setKnob(val,0));
        send_data(TOPLEVEL::action:: forceUpdate, 3, val, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects,2,TOPLEVEL::insert::systemEffectSend);}
        xywh {83 171 30 30} labelsize 10 align 1 maximum 127 step 1
        code0 {o->setValueType(VC_percent127);}
        class WidgetPDial
      }
    }
    Fl_Window panelwindow {
      label {Yoshimi : Mixer Panel}
      callback {Panelclose->do_callback();}
      xywh {421 26 1040 320} type Double labelfont 13 labelsize 13 hide resizable
      code1 {o->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("Mixer Panel"), UNUSED, TOPLEVEL::windowTitle)).c_str());}
    } {
      Fl_Group Panelframe {
        xywh {2 2 1036 286} box ENGRAVED_FRAME
        code0 {//
          for (int i = 0; i < 16; i++)
          {
              panellistitem[i] = new Panellistitem(0, 0, 64, 270, "");
              panellistitem[i]->init(i, bankui, synth);
          }}
      } {}
      Fl_Button towide {
        label {Change to 1 x 16}
        callback {//
        changepanelstyle(1);}
        xywh {360 290 130 25} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64
      }
      Fl_Button todeep {
        label {Change to 2 x 8}
        callback {//
        changepanelstyle(2);}
        xywh {831 290 120 25} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64
      }
      Fl_Choice Panelgroups {
        label {Part Group}
        callback {//
        int result = o->value();
        panelgroup = result * NUM_MIDI_CHANNELS;
        for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
            panellistitem[i]->refresh();}
        xywh {5 300 86 18} down_box BORDER_BOX labelsize 12 labelcolor 64 align 1 textsize 12 textcolor 64
        code0 {o->add("1 to 16");o->add("17 to 32");o->add("33 to 48");o->add("49 to 64");}
        code1 {o->value(panelgroup / NUM_MIDI_CHANNELS);}
      } {}
      Fl_Choice Panelsmallgroups {
        label {Part Group}
        callback {//
        panelgroup = o->value() * NUM_MIDI_CHANNELS;
        for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
            panellistitem[i]->refresh();}
        xywh {5 300 86 18} down_box BORDER_BOX labelsize 12 labelcolor 64 align 1 textsize 12
        code0 {o->add("1 to 16");o->add("17 to 32");}
        code1 {if (panelgroup ==  NUM_MIDI_CHANNELS) o->value(1); else o->value(0);}
      } {}
      Fl_Spinner CSspinner {
        label CC
        callback {//
        CSpend->show();}
        xywh {209 300 50 18} labelsize 12 labelcolor 64 align 1 minimum 0 maximum 127 value 115 textsize 12 textcolor 64
        code0 {CS_CC = synth->getRuntime().channelSwitchCC;}
        code1 {if (CS_CC < 128) o->value(CS_CC); else o->value(115);}
        class WidgetSpinner
      }
      Fl_Button CSpend {
        label Pending
        callback {//
        CS_CC = synth->getRuntime().channelSwitchCC;
        int candidate = CSspinner->value();
        if (candidate == CS_CC)
        {
            o->hide();
            return;
        }

        string name = synth->getRuntime().masterCCtest(candidate);
        if (!name.empty())
        {
            query("", "", "", "In use for " + name);
            if (CS_CC < 128)
            {
                CSspinner->value(CS_CC);
                CSspinner->redraw();
            }

        }
        else
        {
            send_data(TOPLEVEL::action::forceUpdate, MAIN::control::soloCC, CSspinner->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);
        }}
        tooltip {Click to set} xywh {276 290 70 25} box PLASTIC_UP_BOX color 90 labelsize 12 labelcolor 64 hide
      }
      Fl_Choice channelswitch {
        label Solo
        callback {//
                send_data(TOPLEVEL::action::forceUpdate, MAIN::control::soloType, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Assign groups of parts to Ch 1, singly enabled by MIDI} xywh {114 300 74 18} down_box BORDER_BOX labelsize 12 labelcolor 64 align 1 textsize 12 textcolor 64
        code0 {o->add("Off");o->add("Row");o->add("Column");o->add("Loop");o->add("TwoWay");o->add("Channel");}
        code1 {o->value(synth->getRuntime().channelSwitchType);}
        code2 {if (o->value() == 0) CSspinner->hide(); else CSspinner->show();}
        code3 {CS_CC = o->value();}
      } {}
      Fl_Button Panelclose {
        label Close
        callback {//
    panelType |= 4;
    saveWin(synth, panelwindow->w(), panelwindow->h(), panelwindow->x(), panelwindow->y(), panelType, "Mixer");
    panelwindow->hide();}
        xywh {975 290 60 25} box THIN_UP_BOX color 196 labelfont 1 labelcolor 64
      }
    }
    Fl_Window message {
      label Yoshimi
      xywh {58 81 290 85} type Double labelsize 12 labelcolor 64 hide resizable
      code0 {o->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push(""), UNUSED, TOPLEVEL::windowTitle)).c_str());}
      code1 {msgDW = o->w(); msgDH = o->h();}
      code2 {o->size_range(290, 85, 0, 0, 0, 0, 1);}
    } {
      Fl_Box words {
        label {?}
        xywh {5 9 280 45} color 55 selection_color 55 labelfont 1 labelsize 12 labelcolor 64 align 149
      }
      Fl_Button yesdoit {
        label Yes
        callback {//
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, BANK::control::refreshDefaults, 1, TOPLEVEL::type::Integer, TOPLEVEL::section::bank);
                closebutton->do_callback();}
        xywh {49 60 70 20} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64 hide
      }
      Fl_Button cancel {
        label Cancel
        callback {//
                if (msgGroup == TOPLEVEL::msgResponse::refreshBankDefaults)
                    send_data(TOPLEVEL::action::lowPrio, BANK::control::refreshDefaults, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::bank);
                else
                    send_data(0, MIDILEARN::control::cancelLearn, 0, 3, TOPLEVEL::section::midiLearn);
                closebutton->do_callback();}
        xywh {130 60 70 20} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64 hide
      }
      Fl_Button closebutton {
        label Close
        callback {//
                yesdoit->hide();
                cancel->hide();
                message->hide();
                msgSeen = false;}
        xywh {211 60 70 20} color 196 labelcolor 64
      }
    }
    Fl_Window querywindow {
      label Yoshimi user_data_type {void *}
      callback {cancelQ->do_callback();}
      xywh {5 207 420 105} type Double hide resizable
      code0 {queryDW = 420; queryDH = 105;}
      code1 {o->size_range(queryDW, queryDH, 0, 0, 0, 0, 1);} modal
    } {
      Fl_Button yesQ {
        label Yes
        callback {//
    querywindow->hide();}
        xywh {205 80 60 20} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64
        code0 {o->value(0);}
      }
      Fl_Button noQ {
        label No
        callback {//
    querywindow->hide();}
        xywh {276 80 60 20} box PLASTIC_THIN_UP_BOX color 228 labelcolor 64
        code0 {o->value(0);}
      }
      Fl_Button cancelQ {
        label Cancel
        callback {//
    querywindow->hide();}
        xywh {348 80 66 20} color 196 labelfont 1 labelcolor 64
        code0 {o->value(0);}
      }
      Fl_Box typeQ {
        label {?}
        xywh {8 26 45 45} box THIN_DOWN_BOX color 191 labelfont 9 labelsize 40 labelcolor 218
      }
      Fl_Box textQ {
        label {text goes here}
        xywh {65 11 345 63} labelcolor 64 align 128
      }
    }
    Fl_Window textwindow {
      label Yoshimi
      callback {//
      saveWin(synth, o->w(), o->h(), o->x(), o->y(), false, "Master-textin");
      o->hide();}
      xywh {222 50 270 60} type Double labelcolor 64 hide resizable
      code0 {textinDW = o->w(); textinDH = o->h();}
      code1 {o->size_range(textinDW, textinDH, 0, 0, 0, 0, 1);} modal
    } {
      Fl_Input textLine {
        label {input:}
        xywh {20 23 230 25} labelcolor 64 align 1 textcolor 64
      }
    }
    Fl_Window filerwindow {
      label {Yoshimi : Filer}
      callback {//
        filerclose->do_callback();}
      xywh {236 77 550 350} type Double hide resizable
      code0 {filerDW = o->w(); filerDH = o->h();}
      code1 {o->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("File Manager"), UNUSED, TOPLEVEL::windowTitle)).c_str());}
      code2 {o->size_range(filerDW, filerDH, 0, 0, 0, 0, 1);} modal
    } {
      Fl_Input fileroldpath {
        label {file paths}
        callback {//
        if (Fl::event_key() == FL_Enter)
        {
            filernewname->value("");
            string name = string(o->value());
            if (name.back() != '/')
                name += "/";
            if(!file::isDirectory(name))
            {
                if (!dosave && extension != TOPLEVEL::XML::Dir && extension != TOPLEVEL::XML::Bank)
                {
                    alert(synth, "Not a valid path to load from.");
                    return;
                }
                if (choice(synth, "", "Yes", "No", "Add to path?") < 2)
                    return;
                if (file::createDir(name))
                {
                    alert(synth, "Unable to change a path here.");
                    return;
                }
            }
            filerpath = name;
            o->value(name.c_str());
            fillfiler(type_name);
        }}
        tooltip {Current path to use(editable)} xywh {10 20 448 25} labelfont 1 labelsize 12 labelcolor 64 align 1 textfont 1 textsize 12 textcolor 64
      }
      Fl_Button filerback {
        label Up
        callback {//
        if (filerpath == "/")
            return;
        filernewname->value("");
        size_t pos = filerpath.rfind('/', filerpath.length() - 2);
        filerpath = filerpath.substr(0, pos +1);
        if (filerpath.empty())
            filerpath = "/";
        fileroldpath->value(filerpath.c_str());
        fillfiler(type_name);}
        tooltip {Go up one directory in path} xywh {463 21 78 24} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 12 labelcolor 64
      }
      Fl_Group faveGroup {
        label Favourites
        xywh {458 116 85 60} box ENGRAVED_FRAME labelcolor 64
      } {
        Fl_Button filerfave {
          label {Show List}
          callback {//
        setfavourites();}
          tooltip {Examine, re-order or delete entries} xywh {463 123 75 20} box GTK_THIN_UP_BOX color 198 labelfont 1 labelsize 12 labelcolor 64
        }
        Fl_Button faveadd {
          label Add
          callback {//
    string name = string(fileroldpath->value());
    if (name.back() != '/')
        name += "/";
    if (!file::isDirectory(name))
    {
        alert(synth, "Not a valid path");
        return;
    }
    fileroldpath->value(name.c_str());
    filerpath = name;
    favebrowse->add(name.c_str());
    setfavourites();}
          tooltip {Add the current path to the favourites list} xywh {463 150 75 20} box GTK_THIN_UP_BOX color 198 labelfont 1 labelsize 12 labelcolor 64
        }
      }
      Fl_Button filerclose {
        label Close
        callback {//
        if (favourites->visible())
            favecancel->do_callback();
        filerfound.clear();
        filerdone = true;
        filernewname->value("Exit");
        saveWin(synth, filerwindow->w(), filerwindow->h(), filerwindow->x(), filerwindow->y(), false, "Master-filer");}
        xywh {463 320 78 20} color 196 labelfont 1 labelsize 12 labelcolor 64
      }
      Fl_Group filernamegroup {
        label Name
        xywh {10 50 533 26} box ENGRAVED_FRAME labelfont 1 labelsize 12 labelcolor 64 align 2
      } {
        Fl_Input filernewname {
          callback {//
      if (Fl::event_key() == FL_Enter)
          fileruse->do_callback();}
          tooltip {Name of file item to load or save} xywh {14 53 444 20} labelsize 12 labelcolor 64 align 2 textfont 1 textsize 12 textcolor 64
        }
      }
      Fl_Button fileruse {
        label {< Use}
        callback {//
        filerpath = string(fileroldpath->value());
        if (filerpath.back() != '/')
        {
            filerpath += '/';
            fileroldpath->value(filerpath.c_str());
        }
        string leaf = string(filernewname->value());
        if (!dosave || !leaf.empty())
            filerfound = filerpath + leaf;
        // error picked up in main loop
        filerdone = true;}
        tooltip {Apply this name to the path and load/save} xywh {464 53 74 20} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 12 labelcolor 64
      }
      Fl_Check_Button filerOpt8 {
        label {Hide Dirs}
        callback {//
    if (o->value() != 0)
        filerOpt1->deactivate();
    else
        filerOpt1->activate();
    fillfiler(type_name);}
        tooltip {Hide sub directories so that files are easier to see} xywh {490 204 18 18} down_box DOWN_BOX selection_color 64 labelsize 12 labelcolor 64 align 1
        class Fl_Check_Button2
      }
      Fl_Check_Button filerOpt1 {
        label {. (dot) Dirs}
        callback {//
    fillfiler(type_name);}
        tooltip {Show hidden paths} xywh {490 244 18 18} down_box DOWN_BOX selection_color 64 labelsize 12 labelcolor 64 align 1
        class Fl_Check_Button2
      }
      Fl_Check_Button filerOpt2 {
        label {. (dot) Files}
        callback {//
    fillfiler(type_name);}
        tooltip {Show hidden files} xywh {490 284 18 18} down_box DOWN_BOX labelsize 12 labelcolor 64 align 1
        class Fl_Check_Button2
      }
      Fl_Check_Button filerOpt16 {
        label {Hide Files}
        callback {//
    ;}
        xywh {490 130 18 18} down_box DOWN_BOX selection_color 64 labelsize 12 labelcolor 64 align 1 hide
        class Fl_Check_Button2
      }
      Fl_Group filerframe {
        xywh {4 4 542 88} box ENGRAVED_FRAME labelcolor 64
      } {}
      Fl_Group filershort {
        xywh {4 4 542 74} box ENGRAVED_FRAME labelcolor 64
      } {}
      Fl_Group favourites {
        xywh {4 49 542 265} box FLAT_BOX labelcolor 64 hide
      } {
        Fl_Group favename {
          xywh {4 49 542 42} box ENGRAVED_FRAME labelcolor 64
        } {}
        Fl_Browser favebrowse {
          callback {//
        if (!favebrowse->value())
            return;
        int result = favebrowse->value();
        if (result < 1)
            return;
        if (Fl::event_clicks())
        {
            Fl::event_clicks(0);
            faveset->do_callback();
        }
        clearfavelist();
        setfavecolour(result);}
          xywh {5 91 540 220} type Select box FLAT_BOX color 206 labelsize 12 labelcolor 64 textfont 1 textsize 12 textcolor 64
        }
        Fl_Button favecancel {
          label Back
          callback {//
    fileroldpath->activate();
    filernewname->activate();
    fileruse->activate();
    filerback->activate();
    filerfave->activate();
    filerscroll->show();
    faveGroup->show();
    favourites->hide();}
          tooltip {Cancel any selection and return to filer window} xywh {455 61 70 20} box GTK_THIN_UP_BOX color 198 labelfont 1 labelsize 12 labelcolor 64
        }
        Fl_Button favedefault {
          label {Make Default}
          callback {//
    size_t pos = favebrowse->value();
    if (pos > 0)
        favebrowse->move(1, pos);}
          tooltip {Set selected entry as the default (move to top)} xywh {287 61 110 20} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 12 labelcolor 64
        }
        Fl_Button favedelete {
          label Delete
          callback {//
    clearfavelist();
    size_t pos = favebrowse->value();
    setfavecolour(1);
    if (pos > 0)
        favebrowse->remove(pos);}
          tooltip {Remove selected entry} xywh {156 61 70 20} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 12 labelcolor 64
        }
        Fl_Button faveset {
          label Set
          callback {//
    size_t pos = favebrowse->value();
    if (pos > 0)
        filerpath = clearfavecolour(pos);
    else
       filerpath = clearfavecolour(1);

    if (filerpath.back() != '/')
        filerpath += '/';
    fileroldpath->value(filerpath.c_str());
    fillfiler(type_name);
    favecancel->do_callback();}
          tooltip {Set the current path to the selected entry and exit} xywh {20 61 70 20} box PLASTIC_THIN_UP_BOX color 228 labelfont 1 labelsize 12 labelcolor 64
        }
      }
      Fl_Scroll filerscroll {
        xywh {10 96 444 244} type VERTICAL color 7 labelcolor 64
      } {}
    }
  }
  Function {setfiler(string title, string name, bool save, int exten)} {return_type string
  } {
    code {//
    dosave = save;
    extension = exten;
    loadfavourites();

    string lastname = textMsgBuffer.fetch(fetchData(extension, MAIN::control::readLastSeen, TOPLEVEL::section::main));
    string path;
    type_name = "";
    size_t pos = string::npos;
    fileruseX = 464;
    fileruse->copy_label("< New Dir");
    filernamegroup->show();
    filerframe ->show();
    filershort->hide();
    string currentfave = string(favebrowse->text(1)).substr(4);
    if (extension == TOPLEVEL::XML::Dir)
    {
        if (!dosave)
        {
            fileruseX = 234;
            fileruse->copy_label("^ From");
            filernamegroup->hide();
            filerframe ->hide();
            filershort->show();
        }
        path = currentfave;
        filernewname->value("");
        filerOpt16->value(1);
        filerOpt8->hide();
        filerOpt2->hide();
    }
    else if(extension == TOPLEVEL::XML::Bank)
    {
        if(!dosave)
        {
            fileruseX = 234;
            fileruse->copy_label("^ Import");
            path = currentfave + name;
            filernewname->value("");
            filernamegroup->hide();
            filerframe ->hide();
            filershort->show();
        }
        else
        {
            fileruse->copy_label("< Export");
            path = currentfave;
            filernewname->value(name.c_str());
        }
        filerOpt16->value(1); // hide files
        filerOpt8->hide(); // hide dirs
        filerOpt2->hide(); // dot files
    }
    else
    {
        if (extension == TOPLEVEL::XML::ScalaTune || extension == TOPLEVEL::XML::ScalaMap || extension == TOPLEVEL::XML::Themes)
        {
            if (dosave)
                fileruse->copy_label("< Export");
            else
                fileruse->copy_label("< Import");
        }

        else if (dosave)
            fileruse->copy_label("< Save");
        else
            fileruse->copy_label("< Load");
        if (lastname.empty())
        {
            path = currentfave;
            filernewname->value("");
        }
        else
        {
            pos = lastname.rfind('/');
            path = lastname.substr(0, pos);
        }

        if (name.empty() && pos != string::npos)
        {
            name = lastname.substr(pos + 1);
        }
        filerOpt16->value(0);
        filerOpt8->show();
        filerOpt2->show();

        if (!name.empty())
        {
            pos = name.find('.');
            if (pos != string::npos)
                name = name.substr(0, pos);
            filernewname->value(name.c_str());
        }

        switch(extension)
        {
            case TOPLEVEL::XML::Instrument:
                filerext = EXTEN::zynInst;
                fileroldpath->copy_label("Path to Instruments");
                type_name = "xiz";
                break;
            case TOPLEVEL::XML::Patch:
                filerext = EXTEN::patchset;
                fileroldpath->copy_label("Path to Patch Sets");
                type_name = "xmz";
                break;
            case TOPLEVEL::XML::Presets:
                filerext = EXTEN::presets;
                fileroldpath->copy_label("Path to Presets");
                type_name = "xpz";
                break;

            case TOPLEVEL::XML::Scale:
                filerext = EXTEN::scale;
                fileroldpath->copy_label("Path to Scales");
                type_name = "xsz";
                break;
            case TOPLEVEL::XML::State:
                filerext = EXTEN::state;
                fileroldpath->copy_label("Path to States");
                type_name = "state";
                break;
            case TOPLEVEL::XML::Vector:
                filerext = EXTEN::vector;
                fileroldpath->copy_label("Path to Vectors");
                type_name = "xvy";
                break;
            case TOPLEVEL::XML::MLearn:
                filerext = EXTEN::mlearn;
                fileroldpath->copy_label("Path to Midi-Learn files");
                type_name = "xly";
                break;
            case TOPLEVEL::XML::PadSample:
                filerext = EXTEN::MSwave;
                fileroldpath->copy_label("Path to PadSynth samples");
                type_name = "wav";
                break;
            case TOPLEVEL::XML::ScalaTune:
                filerext = EXTEN::scalaTuning;
                fileroldpath->copy_label("Path to Scala tunings");
                type_name = "scl";
                break;
            case TOPLEVEL::XML::ScalaMap:
                filerext = EXTEN::scalaKeymap;
                fileroldpath->copy_label("Path to Scala keymaps");
                type_name = "kbm";
                break;
            case TOPLEVEL::XML::Bank:
                fileroldpath->copy_label("Path to Instrument Banks");
                break;
            case TOPLEVEL::XML::Themes:
             filerext = EXTEN::theme;
                fileroldpath->copy_label("Path to UI themes");
                type_name = "clr";
                break;

        }
    }
    if (!title.empty())
        fileroldpath->copy_label(title.c_str());
    if (path.back() != '/')
        path += '/';
    filerpath = path;
    fileroldpath->value(path.c_str());

    fillfiler(type_name);

    int X, Y, W, H, O;
    loadWin(synth, W, H, X, Y, O, "Master-filer");
    if (W < filerDW || H < filerDH)
    {
        W = filerDW;
        H = filerDH;
    }
    checkSane(X, Y, W, H, filerDW, filerDH);
    filerwindow->resize(X, Y, W, H);

    lastfilerW = 0;
    filerdone = false;
    filerwindow->show();
    lineitem = -1;
    while (true)
    {
        if (lastfilerW != filerwindow->w())
        {
            filerRtext();
            lastfilerW = filerwindow->w();
        }
        Fl::wait();
        if (lineitem > -1)
        {
            filerselect(lineitem);
            lineitem = -1;
        }
        if (filerdone && (extension == TOPLEVEL::XML::Dir || extension == TOPLEVEL::XML::Bank))
        {
            if (dosave && string(filernewname->value()).empty())
            {
                filerdone = false;
                query("", "", "", "Nothing given to use!");
            }
            else
                break;
        }
        else if (filerdone && string(filernewname->value()).empty())
        {
            filerdone = false;
            query("", "", "", "Nothing given to use!");
        }
        else if (filerdone)
        break;
    }
    filerwindow->hide();

    if (extension == TOPLEVEL::XML::Dir || extension == TOPLEVEL::XML::Bank)
    {
        if (dosave)
        {
            if (string(filernewname->value()).length() < 3)
                filerfound.clear();
        }
        else
        {
            if (filerfound.back() != '/')
                filerfound += '/';
        }
    }
    else if (dosave)
    {
        if (extension == TOPLEVEL::XML::Instrument)
        { // try to cover all possibilities!
            int type = fetchData(0, CONFIG::control::savedInstrumentFormat,TOPLEVEL::section::config);
            if ((type == 3 || type == 1) && isRegularFile(filerfound + EXTEN::zynInst))
            {
                if (query("", "Yes", "No", "The file exists. \\nOverwrite it?") < 2)
                    filerfound.clear();
            }
            else if ((type == 3 || type == 2) && isRegularFile(filerfound + EXTEN::yoshInst))
            {
                if (query("", "Yes", "No", "The file exists. \\nOverwrite it?") < 2)
                    filerfound.clear();
            }
        }
        else if (isRegularFile(filerfound + filerext))
        {
            if (query("", "Yes", "No", "The file exists. \\nOverwrite it?") < 2)
            {
                filerfound.clear();
            }
        }
    }
    savefavourites();
    return filerfound;} {}
  }
  Function {fillfiler(string type_name)} {} {
    code {//
        string tofetch;
        int options = filerOpt1->value();
        if (filerOpt2->value() > 0)
            options |= 2;
        if (filerOpt8->value() > 0)
            options |= 8;
        if (filerOpt16->value() > 0)
            options |= 16;

        file::dir2string(tofetch, filerpath, filerext, options);
        filerlist.clear();        // Note: must come first; dtor of FL_Group automatically
        filerscroll->clear();     //       detaches child widgets from the FL_Scroll
        lineno = 0;
        //std::cout << "*** list start ***" << std::endl;
        //std::cout << "ext " << filerext << std::endl;
        while(!tofetch.empty())
        {
            size_t pos = tofetch.find("\\n");
            string next = tofetch.substr(0, pos);
            bool isDir = false;
            filerlist.emplace_back(0, 0, 390, 20);
            if (next.find("Dir:") != std::string::npos)
            {
                next = next.substr(5);
                isDir = true;
            }
            filerlist.back().init(synth,lineno, isDir, type_name, next);
            //std::cout << "name >" << next << "<" << std::endl;
            filerlist.back().name->copy_label(next.c_str());
            filerscroll->add(&filerlist.back());
            ++lineno;
            tofetch = tofetch.substr(pos + 1);
        }
        filerscroll->end();
        filerscroll->scroll_to(-10,-10);
        filerRtext();
        //std::cout << "list end " << lineno << std::endl;} {}
  }
  Function {filerselect(int item)} {} {
    code {//
        string line = string(filerlist[item].name->label());
        if (filerlist[item].dirIcon->visible())
        {
            //std::cout << "in dir" << std::endl;
            if (line.back() !='/')
                line += '/';
            if (Fl::event_clicks())
            {
                Fl::event_clicks(0);
                filerpath = filerpath + line;
                fileroldpath->value(filerpath.c_str());
                fillfiler(type_name);
            }
            return;
        }
        //std::cout << "files" << std::endl;
        filernewname->value(line.c_str());
        if (Fl::event_clicks())
        {
            Fl::event_clicks(0);
            fileruse->do_callback();
        }} {}
  }
  Function {setfavourites()} {} {
    code {//
    fileroldpath->deactivate();
    filernewname->deactivate();
    fileruse->deactivate();
    filerback->deactivate();
    filerfave->deactivate();
    filerscroll->hide();
    faveGroup->hide();
    favourites->show();} {}
  }
  Function {loadfavourites()} {} {
    code {//
        string favetext = file::loadText(file::configDir() + "/yoshimi-favourites");
        if (favetext.empty())
            favetext = file::userHome();
        favebrowse->clear();
        string cr = "\\n";
        for (int count = 0; count < 20; ++count)
        {
            size_t pos = favetext.find(cr);
            string next = favetext.substr(0, pos);
            favebrowse->add(next.c_str());
            favetext = favetext.substr(pos + 1);
            if (pos == string::npos)
                break;
        }
        setfavecolour(1);} {}
  }
  Function {savefavourites()} {} {
    code {//
    clearfavelist();
    string favetext;
    string cr = "\\n";
    for (int i = 1; i <= favebrowse->size(); ++ i)
    {
        string line = string(favebrowse->text(i));
        favetext += (line + cr);
    }
    file::saveText(favetext, file::configDir() + "/yoshimi-favourites");} {}
  }
  Function {clearfavelist()} {} {
    code {//
    for (int i = 1; i <= favebrowse->size(); ++ i)
    {
        string line = string(favebrowse->text(i));
        if (line.substr(0, 4) == "@C4 ")
        {
            line = line.substr(4);
            favebrowse->text(i, line.c_str());
        }
    }} {}
  }
  Function {setfavecolour(int num)} {} {
    code {//
    string line = "@C4 " + string(favebrowse->text(num));
    favebrowse->text(num, line.c_str());} {}
  }
  Function {clearfavecolour(int num)} {return_type string
  } {
    code {//

        string line = string(favebrowse->text(num));
        if (line.substr(0, 4) == "@C4 ")
            line = line.substr(4);
        return line;} {}
  }
  Function {filerRtext()} {} {
    code {//
        float dScale = filerwindow->w() / float(filerDW);
        int size12 = int(12 * dScale);
        int size14 = int(14 * dScale);

        fileroldpath->labelsize(size12);
            fileroldpath->textsize(size12);
        filernamegroup->labelsize(size12);
            filernewname->textsize(size12);
        faveGroup->labelsize(size14);
        fileruse->position(fileruseX * dScale, 53 * dScale);
        fileruse->labelsize(size12);

        filerback->labelsize(size12);
        faveadd->labelsize(size12);
        filerfave->labelsize(size12);

        filerOpt8->labelsize(size12);
        filerOpt1->labelsize(size12);
        filerOpt2->labelsize(size12);

        filerclose->labelsize(size12);

        favename->labelsize(size14);
        favebrowse->textsize(size12);
        favecancel->labelsize(size12);
        favedefault->labelsize(size12);
        favedelete->labelsize(size12);
        faveset->labelsize(size12);
        for (int i = 0; i < lineno; ++i)
        {
            filerlist[i].resize(int(10 * dScale), int(((i * 20) + 96) * dScale), int(440 * dScale), int(20 * dScale));
            filerlist[i].name->labelsize(size12);
            filerlist[i].type->labelsize(int(4 * dScale));
        }
        filerwindow->redraw();} {}
  }
  Function {startInstance()} {} {
    code {//
    cancelInst->value(0);
    nextInst->value(0);
    valueInst->value("");
    setInstance->show();
    while (setInstance->visible())
    {
        if (cancelInst->value())
        {
            setInstance->hide();
            break;
        }
        if (nextInst->value())
        {
            send_data(TOPLEVEL::action::lowPrio, MAIN::control::startInstance, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
            setInstance->hide();
            break;
        }
        if (Fl::get_key(FL_Enter))
        {
            string testval = valueInst->value();
            if (!testval.empty())
            {
                if (func::isDigits(testval))
                {
                    int result = stoi(testval);
                    if (result > 0 && result < 32)
                    {
                        send_data(TOPLEVEL::action::lowPrio, MAIN::control::startInstance, result, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
                        setInstance->hide();
                        break;
                    }
                }
            }
        }
        Fl::wait();
    };} {}
  }
  Function {send_data(int action, int control, float value, int type, int part = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int miscmsg = UNUSED)} {} {
    code {//
        type |= TOPLEVEL::type::Write;
        /*
            The following variations are due to the way the section was built
            up over time. It really needs the whole lot expanding for the calls
            to natively include all parameters.
        */
        if (control == MAIN::control::loadInstrumentByName && part == TOPLEVEL::section::main && miscmsg < NO_MSG)
        {
            collect_writeData(synth, 0, action, type, control, part, engine, UNUSED, UNUSED, UNUSED, UNUSED, miscmsg);
            return;
        }

        if (control <= MAIN::control::soloType)
            type |= Fl::event_button();
        if (parameter == 0)
        {
            collect_writeData(synth, 0, action, type, control, part, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, miscmsg);
            return;
        }

        collect_writeData(synth, value, action, type, control, part, UNUSED, engine, insert, parameter, UNUSED, miscmsg);} {}
  }
  Function {fetchData(float value, int control, int part, int kititem = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int offset = UNUSED, int miscmsg = UNUSED, int request = UNUSED)} {return_type float
  } {
    code {//
        return collect_readData(synth, value, control, part, kititem, engine, insert, parameter, offset, miscmsg, request);} {}
  }
  Function {part_group_returns(CommandBlock *getData)} {return_type bool
  } {
    code {//
        float value = getData->data.value;
        unsigned char control = getData->data.control;
        unsigned char newpart = getData->data.part;
        int value_int = lrint(value);
        bool value_bool = _SYS_::F2B(value);
        int panelpart = 0;
        bool panelVisible = ((newpart / NUM_MIDI_CHANNELS) == (panelgroup / NUM_MIDI_CHANNELS));
        if (panelVisible)
            panelpart = newpart % NUM_MIDI_CHANNELS;

        bool seen = false;;
        switch (control)
        {
            case PART::control::enable:
            {
                if (npart == newpart)
                {
                    partEnable->value(value);
                    if (value)
                        partControls->activate();
                    else
                        partControls->deactivate();
                }
                if (panelVisible)
                {
                    panellistitem[panelpart]->partenabled->value(value);
                    if (value)
                        panellistitem[panelpart]->panellistitemgroup->activate();
                    else
                        panellistitem[panelpart]->panellistitemgroup->deactivate();
                }
                seen = true;
                break;
            }
            case PART::control::volume:
                partVol->value(value);
                partVol->selection_color(setKnob(value,96));
                if (panelVisible)
                {
                    panellistitem[panelpart]->partvolume->value(value);
                    panellistitem[panelpart]->partvolume->selection_color(setSlider(value,96));
                }
                seen = true;
                break;
            case PART::control::panning:
                partPan->value(value);
                partPan->selection_color(setKnob(value,64));
                if (panelVisible)
                {
                    panellistitem[panelpart]->partpanning->value(value);
                    panellistitem[panelpart]->partpanning->selection_color(setKnob(value,64));
                }
                seen = true;
                break;
            case PART::control::velocityOffset:
                partVelOffset->value(value);
                partVelOffset->selection_color(setKnob(value,64));
                seen = true;
                break;

            case PART::control::velocitySense:
                partVelSense->value(value);
                partVelSense->selection_color(setKnob(value,64));
                seen = true;
                break;

            case PART::control::midiChannel:
            {
                int tmp = value_int;
                int textCol = gen_text;
                if (tmp >= NUM_MIDI_CHANNELS)
                {
                    if (tmp >= NUM_MIDI_CHANNELS * 2)
                        textCol = midi_ignored;
                    else
                        textCol = gen_text;
                    tmp = (tmp % NUM_MIDI_CHANNELS);
                }
                partMidiCh->textcolor(textCol);
                partMidiCh->value(tmp + 1);
                if (panelVisible)
                {
                    panellistitem[panelpart]->partrcv->textcolor(textCol);
                    panellistitem[panelpart]->partrcv->value(tmp);
                }
                seen = true;
                break;
            }

            case PART::control::keyMode:
                partKeymode->value(value_int);
                updateModepatch(value_int > 1 && partui->part->Pdrummode != 0);
                seen = true;
                break;

            case PART::control::drumMode: // we allow this to cayry on to PartUI
                updateModepatch(value_bool != 0 && partKeymode->value() > 1);
                break;

            case PART::control::portamento:
                partPortamento->value(value_bool);
                break;

            case PART::control::instrumentName:
                partui->checkEngines();
                synth->getGuiMaster()->instrumentlabel->copy_label(synth->part[newpart]->Pname.c_str());
                seen = true;
                break;

            case PART::control::minNote:
            case PART::control::minToLastKey: // this will have been modified for last key press
                minKeyCount->value(value_int);
                seen = true;
                break;

            case PART::control::maxNote:
            case PART::control::maxToLastKey: // this will have been modified for last key press
                maxKeyCount->value(value_int);
                seen = true;
                break;

            case PART::control::resetMinMaxKey:
                minKeyCount->value(0);
                maxKeyCount->value(127);
                seen = true;
                break;

            case PART::control::keyShift:
                partKeyShift->value(value_int);
                seen = true;
                break;

            case PART::control::maxNotes:
                partKeyLimit->value(value_int);
                seen = true;
                break;

            case PART::partToSystemEffect1:
                sysEff1->value(value);
                sysEff1->selection_color(setKnob(value,0));
                seen = true;
                break;
            case PART::partToSystemEffect2:
                sysEff2->value(value);
                sysEff2->selection_color(setKnob(value,0));
                seen = true;
                break;
            case PART::partToSystemEffect3:
                sysEff3->value(value);
                sysEff3->selection_color(setKnob(value,0));
                seen = true;
                break;
            case PART::partToSystemEffect4:
                sysEff4->value(value);
                sysEff4->selection_color(setKnob(value,0));
                seen = true;
                break;

            case PART::control::audioDestination:
                int send = value_int - 1;
                if (send < 0 or send > 2)
                    send = 0;
                if (panelVisible)
                    panellistitem[panelpart]->audiosend->value(send);
                seen = true;
                break;
        }
        return seen;} {}
  }
  Function {returns_update(CommandBlock *getData)} {return_type bool
  } {
    code {//
    float value = getData->data.value;
    bool wasFromHere = ((getData->data.source & TOPLEVEL::action::noAction) == TOPLEVEL::action::fromGUI);
    unsigned char control = getData->data.control;
    unsigned char newpart = getData->data.part;
    unsigned char kititem = getData->data.kit;
    unsigned char engine = getData->data.engine;
    unsigned char insert = getData->data.insert;
    unsigned char parameter = getData->data.parameter;
    unsigned char miscmsg = getData->data.miscmsg;
    int value_int = lrint(value);
    bool value_bool = _SYS_::F2B(value);
    int chan = kititem & 0x3f;
    bool isSingle = kititem >= 0x40;
    int mask = NUM_MIDI_CHANNELS - 1;
    string name;
    if (miscmsg != NO_MSG)
        name = textMsgBuffer.fetch(miscmsg);
    if (newpart == TOPLEVEL::section::midiIn)
    {
        if (engine == MIDI::CC::volume && partui->part->ctl->volume.receive == 0)
            return false; // disabled
        if (engine == MIDI::CC::expression && partui->part->ctl->expression.receive == 0)
            return false; // disabled

        float vol = (value * synth->part[npart]->ctl->volume.data) / 127;
        if (control == MIDI::control::controller)
        { // MIDI panel entries only
            for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
            {
                if (panellistitem[i]->partenabled->value() != 0)
                {
                    if ((isSingle && i == (chan & mask)
                                 && panellistitem[i]->partrcv->value() == (chan & mask)
                                 && (chan / NUM_MIDI_CHANNELS) == (panelgroup / NUM_MIDI_CHANNELS))
                         || (!isSingle && panellistitem[i]->partrcv->value() == (chan & mask)))
                    {
                        if (engine == MIDI::CC::volume)
                        {
                            panellistitem[i]->partvolume->value(vol);
                            panellistitem[i]->partvolume->selection_color(setSlider(vol,96));
                        }
                        else if (engine == MIDI::CC::panning)
                        {
                            panellistitem[i]->partpanning->value(value);
                            panellistitem[i]->partpanning->selection_color(setKnob(value,64));
                        }
                    }
                }
            }
        }

        bool isForUs = (isSingle && chan == npart)
             || (!isSingle &&  (partMidiCh->value() == (chan & mask) + 1));
        switch(control)
        {
            case MIDI::control::noteOn:
            case MIDI::control::noteOff:
                break;
            case MIDI::control::controller:
                if (engine <= 119 && engine == synth->getRuntime().channelSwitchCC)
                { // it's a valid channel switch
                    int newch = partMidiCh->value() - 1;
                    switch (synth->getRuntime().channelSwitchType)
                    {
                        case MIDI::SoloType::Row:
                            if (npart < NUM_MIDI_CHANNELS)
                            {
                                if (npart != value_int)
                                    newch = NUM_MIDI_CHANNELS;
                                else
                                    newch = 0;
                            }
                            break;

                        case MIDI::SoloType::Column:
                            if (value_int == npart)
                                newch = (value_int & mask);
                            else if ((value_int & mask) == (npart & mask))
                                newch = (value_int & mask) + NUM_MIDI_CHANNELS;
                            break;

                        case MIDI::SoloType::Loop:
                        case MIDI::SoloType::TwoWay:
                            if (npart < NUM_MIDI_CHANNELS)
                            {
                                if (npart == synth->getRuntime().channelSwitchValue)
                                    newch = 0;
                                else if (value_int > 0)
                                    newch = NUM_MIDI_CHANNELS;
                            }
                            break;

                        case MIDI::SoloType::Channel:
                            //int ch = value_int % NUM_MIDI_CHANNELS;
                            if (newch == chan || newch == chan + NUM_MIDI_CHANNELS)
                                newch = chan;
                            else
                                newch = newch + NUM_MIDI_CHANNELS;
                            break;

                    }
                    partMidiCh->value(newch + 1);

                    //if (newch < NUM_MIDI_CHANNELS)
                        partMidiCh->textcolor(gen_text);
                    //else
                        //partMidiCh->textcolor(midi_solo_release);
                    updatepanel();
                }
                else if (isForUs)
                {
                    switch(engine)
                    {
                        case MIDI::CC::modulation:
                            partui->modulation->value(value);
                            partui->modulation->selection_color(setKnob(value,64));
                            break;
                        case MIDI::CC::volume:
                            partVol->value(vol);
                            partVol->selection_color(setKnob(vol,96));
                            break;
                        case MIDI::CC::panning:
                            partPan->value(value);
                            partPan->selection_color(setKnob(value,64));
                            break;
                        case MIDI::CC::expression:
                            partui->expression->value(value);
                            partui->expression->selection_color(setKnob(value,127));
                            break;
                        case MIDI::CC::legato:
                        {
                            int mode = synth->ReadPartKeyMode(npart);
                            if (mode > 1)
                                partKeymode->value(2);
                            else
                                partKeymode->value(mode);
                            updateModepatch(mode > 1 && partui->drumMode->value() != 0);
                            break;
                        }
                        case MIDI::CC::filterQ:
                            partui->filterq->value(value);
                            partui->filterq->selection_color(setKnob(value,64));
                            break;
                        case MIDI::CC::filterCutoff:
                            partui->filtercutoff->value(value);
                            partui->filtercutoff->selection_color(setKnob(value,64));
                            break;
                        case MIDI::CC::bandwidth:
                            partui->masterbandwidth->value(value);
                            partui->masterbandwidth->selection_color(setKnob(value,64));
                            break;
                    }
                }
                break;
            case MIDI::control::bankChange:
                if (engine != UNUSED)
                    bankui->readbankcfg();
                bankui->rescan_for_banks();
                break;
        }
        return false;
    }
    if (newpart == TOPLEVEL::section::systemEffects)
    {
        if (insert == TOPLEVEL::insert::systemEffectSend && !wasFromHere)
        {
            switch (engine)
            {
                case 0:
                    if(control == 1)
                    {
                        syseff01->value(value_int);
                        syseff01->selection_color(setKnob(value_int,0));
                    }
                    else if(control == 2)
                    {
                        syseff02->value(value_int);
                        syseff02->selection_color(setKnob(value_int,0));
                    }
                    else if(control == 3)
                    {
                        syseff03->value(value_int);
                        syseff03->selection_color(setKnob(value_int,0));
                    }
                    break;
                case 1:
                    if(control == 2)
                    {
                        syseff12->value(value_int);
                        syseff12->selection_color(setKnob(value_int,0));
                    }
                    else if(control == 3)
                    {
                        syseff13->value(value_int);
                        syseff13->selection_color(setKnob(value_int,0));
                    }
                    break;
                case 2:
                    if(control == 3)
                    {
                        syseff23->value(value_int);
                        syseff23->selection_color(setKnob(value_int,0));
                    }
                    break;
            }
        }

        else
        {
            if (control == EFFECT::sysIns::effectNumber)
            {   //note: using local settings from the last push-update into MirrorData
                syseffnocounter->value(syseffectui->effNum() + 1);
                sysefftype->value(syseffectui->effType());
                syseffectui->refresh();
                syseffectui->UpdatePresetColour(parameter, sysefftype->value());
                SysEffOn->value(syseffectui->isEnabled());
                if (SysEffOn->value())
                    sysefftype->activate();
                else
                    sysefftype->deactivate();
            }
            else if (control == EFFECT::sysIns::effectType)
            {
                syseffnocounter->value(syseffectui->effNum() + 1);
                sysefftype->value(syseffectui->effType());
                syseffectui->refresh();
                syseffectui->UpdatePresetColour(0, sysefftype->value());
                // changing effect type always sets default values
                if (sysinsgroup->value() == SystemEffectsGrp)
                {
                    showSysEfxUI();
                    syseffectui->effRtext(mainScale, sysefftype->value());
                }
            }
            else if (control == EFFECT::sysIns::effectEnable)
            {
               SysEffOn->value(value_bool);
               if (value_bool)
                    sysefftype->activate();
                else
                    sysefftype->deactivate();
            }
        }
        return false;
    }
    else if (newpart == TOPLEVEL::section::insertEffects)
    {
        if (control == EFFECT::sysIns::effectNumber)
        {
            refreshInsEffUI();
            if (sysinsgroup->value() == InsertionEffectsGrp)
                showInsEfxUI();
            inseffectui->UpdatePresetColour(parameter, insefftype->value());

        }
        else if (control == EFFECT::sysIns::effectType)
        {
            refreshInsEffUI();
            inseffectui->UpdatePresetColour(0, insefftype->value());
            // changing effect type always sets default values
            if (sysinsgroup->value() == InsertionEffectsGrp)
            {
                showInsEfxUI();
                inseffectui->effRtext(mainScale, insefftype->value());
            }
        }
        else if (control == EFFECT::sysIns::effectDestination)
        {
            inseffpart->value(value_int + 2);
            if (value_int == -1)
                insefftype->deactivate();
            else
            {
                insefftype->activate();
                refreshInsEffUI();
                if (sysinsgroup->value() == InsertionEffectsGrp)
                    showInsEfxUI();
            }
        }
        return false;
    }

    switch(control)
    {
        case MAIN::control::volume:
            mastervolumedial->value(value);
            mastervolumedial->selection_color(setKnob(value,90));
            break;

        case MAIN::control::partNumber:
            if ((getData->data.source & TOPLEVEL::action::noAction) != TOPLEVEL::action::fromGUI)
                activePart = value_int;

            partSwitch(activePart);
            updatepanel();
            break;

        case MAIN::control::availableParts:
            partmax = value_int;
            npartcounter->range(1, partmax);
            updatepart();
            updatepanel();
            setinspartlist();
            vectorui->checkParts(value_int);
            break;
        case MAIN::control::panLawType:
            panning_law->value(value_int);
            break;

        case MAIN::control::detune:
            globalfinedetune->value(value);
            globalfinedetune->selection_color(setKnob(value,64));
            break;

        case MAIN::control::keyShift:
            masterkeyshift->value(value_int);
            break;

        case MAIN::control::bpmFallback:
            setBpmFallbackValue(value);
            break;

        case MAIN::control::mono:
            mastermono->value(value_int);
            if (value_int)
                mastermono->label("Mono");
            else
                mastermono->label("Stereo");
            break;

        case MAIN::control::soloType:
            channelswitch->value(value_int);
            if (value_int == 0)
            {
                CS_CC = 128;
                CSspinner->value(115); // default
                CSspinner->hide();
                CSpend->hide();
                for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
                    setPanelPartMidiWidget(i, i);
            }
            else
            {
                CS_CC = 115;
                CSspinner->value(115);
                CSpend->show();
                CSspinner->show();
                for (int i = 1; i < NUM_MIDI_CHANNELS; ++i)
                {
                    if (value_int == 2)
                        setPanelPartMidiWidget(i, i);
                    else
                        setPanelPartMidiWidget(i, 16);
                }
            }
            panelwindow->changed();
            break;
        case MAIN::control::soloCC:
            updatepanel();
            break;
        case MAIN::control::exportBank:
            if (wasFromHere)
                query("", "", "", name);
            break;
        case MAIN::control::importBank: // import bank
            if (wasFromHere)
            {
                if (name.find("FAILED") == 1)
                    query("", "", "", name);
                else
                {
                    unsigned int other = name.find(" : ");
                    if (other < 1024) // a bit of a hack :(
                    {
                        name = name.substr(other + 3);
                        query("", "", "", name);
                    }
                }
            }
            bankui->rescan_for_banks();
            break;
        case MAIN::control::deleteBank: // delete bank and contents
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            bankui->rescan_for_banks();
            bankui->set_bank_slot();
            break;

        case MAIN::control::loadInstrumentFromBank:
            bankui->refreshinstrumentwindow();
            updatepartprogram(kititem);
            break;

        case MAIN::control::loadInstrumentByName:
            updatepartprogram(kititem);
            break;

        case MAIN::control::saveNamedInstrument: // save instrument
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                partui->setinstrumentlabel();
                panellistitem[newpart % NUM_MIDI_CHANNELS]->refresh();
                //RecentInstruments->activate();
            }
            break;

        case MAIN::control::loadNamedPatchset: // load patchset
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                vectorui->RefreshChans();
                //RecentParams->activate();
                setMasterLabel(findLeafName(name));
                refresh_master_ui(2);
            }
            lastsyseffeqW = 0;
            lastsysDynFiltW = 0;
            lastinsDynFiltW = 0;
            break;

        case MAIN::control::saveNamedPatchset: // save patch set
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                setMasterLabel(findLeafName(name));
                //RecentParams->activate();
            }
            break;

        case MAIN::control::loadNamedVector: // load vector
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                vectorui->setLoadLabelRemote(insert, synth->getRuntime().vectordata.Name[insert]);
                setMasterLabel(findLeafName(name) + " - Vector " + to_string(int(insert) + 1));
                vectorui->setRecent(true);
                refresh_master_ui(5);
            }
            break;

        case MAIN::control::saveNamedVector: // save vector
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                setMasterLabel(findLeafName(name) + " - Vector " + to_string(int(insert) + 1));
                vectorui->setRecent(true);
            }
            break;

        case MAIN::control::loadNamedScale: // load scales
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    query("", "", "", name);
            }
            else
            {
                //RecentScale->activate();
                microtonalui->microtonaluiwindow->hide();
                microtonalui->make_window();
                microtonalui->showScales();
            }
            break;

        case MAIN::control::saveNamedScale: // save scales
            if (wasFromHere && name.find("FAILED") == 1)
                query("", "", "", name);
            //else
                //RecentScale->activate();
            break;

        case MAIN::control::loadNamedState: // load state
            if (wasFromHere && name.find("FAILED") == 1)
            {
                query("", "", "", name);
                refresh_master_ui(1);
            }
            else
            {
                setMasterLabel(findLeafName(name) + " - State");
                refresh_master_ui(0x14);
            }
            break;

        case MAIN::control::saveNamedState: // save state
            if (wasFromHere && name.find("FAILED") == 1)
                query("", "", "", name);
            else
                setMasterLabel(findLeafName(name) + " - State");
            break;
        case MAIN::control::defaultPart:
        case MAIN::control::defaultInstrument:
            partSwitch(activePart);
            updatepanel();
            break;
        case MAIN::control::masterReset:
            if (newpart == TOPLEVEL::section::main)
            {
                refresh_master_ui(1);
                vumeter->init(-1, synth);
                resetPartsClip();
            }
            else if (newpart < NUM_MIDI_PARTS)
                partSwitch(newpart);
            setMasterLabel("");
            break;

        case MAIN::control::masterResetAndMlearn:
            refresh_master_ui(1);
            resetPartsClip();
            if (midilearnui)
                midilearnui->midilearnwindow->hide();//Hide();
            setMasterLabel("");
            break;

        case MAIN::control::openManual:
            message->hide();
            if (miscmsg != NO_MSG)
                query("", "", "", textMsgBuffer.fetch(miscmsg));
            break;

        case MAIN::control::startInstance: // new instance (do nothing here)
            break;

        case MAIN::control::stopSound:
            virkeyboard->relaseallkeys();
            vumeter->init(-1, synth);
            resetPartsClip();
            break;
    }
    return false;} {}
  }
  Function {paste(CommandBlock *getData)} {} {
    code {//
          if (getData->data.part == TOPLEVEL::section::systemEffects)
          {
              sysinsgroup->value(SystemEffectsGrp);
              sysefftype->value(syseffectui->effType());
              syseffnocounter->value(syseffectui->effNum() + 1);
              syseffectui->refresh();
              syseffectui->UpdatePresetColour(0, sysefftype->value());
              showSysEfxUI();
          }
          else
          {
              sysinsgroup->value(InsertionEffectsGrp);
              refreshInsEffUI();
              inseffectui->UpdatePresetColour(0, insefftype->value());
              showInsEfxUI();
          }} {}
  }
  Function {query(string one, string two, string three, string text)} {return_type int
  } {
    code {//
    if (one.empty())
        yesQ->hide();
    else
    {
        if(one == "!")
        {
            yesQ->copy_label("Yes");
        }
        else
        {
            yesQ->copy_label(one.c_str());
        }
        yesQ->show();
    }

    if (two.empty())
        noQ->hide();
    else
    {
        if (two == "!")
        {
            noQ->copy_label("No");
        }
        else
        {
            noQ->copy_label(two.c_str());
        }
        noQ->show();
    }
    if (three.empty())
    {
        cancelQ->copy_label("Close");
        typeQ->copy_label("!");
    }
    else
    {
        if (three == "!")
        {
            cancelQ->copy_label("Cancel");
        }
        else
        {
            cancelQ->copy_label(three.c_str());
        }
        typeQ->copy_label("?");
    }

    textQ->copy_label(text.c_str());

    int X, Y, W, H, O;
    loadWin(synth, W, H, X, Y, O, "Master-query");

    if (W < queryDW || H < queryDH)
    {
        W = queryDW;
        H = queryDH;
    }
    checkSane(X, Y, W, H, queryDW, queryDH);
    querywindow->resize(Fl::event_x_root() + 16, Fl::event_y_root(), W, H);

    querywindow->show();
    int result = 0;
    while(querywindow->shown())
    {
        querywindow->show(); // keep it on top
        queryRtext();
        if (yesQ->value())
            result = 3;
        else if (noQ->value())
            result = 2;
        else if  (cancelQ->value())
            result = 1;
        Fl::wait();
    }
    saveWin(synth, querywindow->w(),querywindow->h(), querywindow->x(), querywindow->y(), false, "Master-query");
    return result;} {}
  }
  Function {setmessage(int group, bool fixedPos, string text, string B1 = "Close", string B2 = "", string B3 = "")} {} {
    code {//
        msgGroup = group;
        if (B3.empty())
            yesdoit->hide();
        else
        {
            yesdoit->copy_label(B3.c_str());
            yesdoit->show();
        }
        if (B2.empty())
            cancel->hide();
        else
        {
            cancel->copy_label(B2.c_str());
            cancel->show();
        }
        closebutton->copy_label(B1.c_str());
        int X, Y, W, H, O;
        loadWin(synth, W, H,  X,  Y, O, "Master-message");
        if(W < msgDW || H < msgDW)
        {
            W = msgDW;
            H = msgDH;

        }
        checkSane(X, Y, W, H, msgDW, msgDH);

        if (fixedPos)
            message->resize(masterwindow->x() + masterwindow->w() / 2 - message->w() / 2, masterwindow->y() + masterwindow->h() / 2 - message->h() / 2, W, H);
        else
            message->resize(Fl::event_x_root() + 16, Fl::event_y_root(), W, H);
        words->copy_label(text.c_str());
        message->show();} {}
  }
  Function {setinput(string label, string oldLine)} {return_type string
  } {
    code {//
    textLine->copy_label(label.c_str());
    textLine->value(oldLine.c_str());
    int X, Y, W, H, O;
    loadWin(synth, W, H, X, Y, O, "Master-textin");
    X = Fl::event_x_root(); // always want these relative to parent
    Y = Fl::event_y_root();
    if(W < textinDW || H < textinDH)
    {
        W = textinDW;
        H = textinDH;
    }
    checkSane(X, Y, W, H, textinDW, textinDH, true);

    textwindow->size(W, H);
    textwindow->show();
    string result;
    string oldline = textLine->value();
    size_t pos = 1;
    while (textwindow->shown())
    {
        textwindow->show(); // keep it on top
        textinRtext();
        result = string(textLine->value());
        Fl::wait();
        pos = result.find_last_not_of(' ');
        if (pos != string::npos)
            pos -= result.find_first_not_of(' ');
        if (Fl::event_key() == FL_Enter)
        {
            if (pos == 0 || pos > 1)
                textwindow->hide();
            else
                textLine->copy_label("Must be at least 3 letters or none");
        }
    }
    saveWin(synth, textwindow->w(), textwindow->h(), textwindow->x(), textwindow->y(), false, "Master-textin");
    if (pos == 0 || pos == string::npos)
        return oldline;

    return result;} {}
  }
  Function {updatesendwindow()} {} {
    code {//

        ;} {}
  }
  Function {updatelistitem(int part)} {} {
    code {//
    int tmp = part % NUM_MIDI_CHANNELS;
    panellistitem[tmp]->refresh();} {}
  }
  Function {changepanelstyle(int type)} {} {
    code {//
    if (type == 0)
        type = 1;
    panelwindow->hide();
    if (type != panelType)
    {
        if (type == 1)
        {
            panelwindow->size(PANEL_SINGLE_X, PANEL_SINGLE_Y);
            panelwindow->size_range((PANEL_SINGLE_X * 9) / 10, (PANEL_SINGLE_Y * 9) / 10, 0, 0, 0, 0, 1);
            towide->hide();
            todeep->show();
            Panelclose->position(975, 290);
        }
        else if (type == 2)
        {
            panelwindow->size(PANEL_DUAL_X, PANEL_DUAL_Y);
            panelwindow->size_range((PANEL_DUAL_X * 4) / 5, (PANEL_DUAL_Y * 4) / 5, 0, 0, 0, 0, 1);
            towide->show();
            todeep->hide();
        }
    }
    panelwindow->show();
    panelType = type;
    panelRtext();} {}
  }
  Function {Showpanel()} {} {
    code {//
    int fetchW, fetchH, fetchX, fetchY, fetchO;
    loadWin(synth, fetchW, fetchH, fetchX, fetchY, fetchO, "Mixer");
    if (fetchO == 0)
        fetchO = 1; // it's never been seen so set the default

    // assume default sizes
    int defW = (PANEL_SINGLE_X * 9) / 10;
    int defH = (PANEL_SINGLE_Y * 9) / 10;

    if (fetchW < (PANEL_DUAL_X * 9) / 10 || fetchH < defH)
    {
        fetchW = defW;
        fetchH = defH;
        fetchO = 1; // it's messed up so force default
    }

    int tmp = fetchO & 3;
    if (tmp == 2)
    {
        defW = (PANEL_DUAL_X * 9) / 10;
        defH = (PANEL_DUAL_Y * 9) / 10;
    }

    if (tmp == 1)
    {
        towide->hide();
        todeep->show();
    }
    else if (tmp == 2)
    {
        towide->show();
        todeep->hide();
    }

    panelwindow->size_range(defW, defH, 0, 0, 0, 0, 1);
    checkSane(fetchX, fetchY, fetchW, fetchH, defW, defH);
    panelwindow->resize(fetchX, fetchY, fetchW, fetchH);

    if (fetchO < 4)
    {
        panelType = tmp;
        panelwindow->show();
        updatepanel();
    }
    else
    {
        panelType = fetchO;
        panelwindow->hide();
    }} {}
  }
  Function {updatepanel(bool full = false)} {} {
    code {//
    for (int part = 0; part < partmax; ++part)
    {
        if (part < NUM_MIDI_CHANNELS) // will be orred with panel group
            panellistitem[part]->refresh();
        vectorui->setInstrumentLabel(part);
    }

    if (partmax == (NUM_MIDI_CHANNELS * 4))
    {
        Panelgroups->value(npart / NUM_MIDI_CHANNELS);
        Panelgroups->show();
    }
    else
        Panelgroups->hide();

    if (partmax == (NUM_MIDI_CHANNELS * 2))
    {
        Panelsmallgroups->value(npart / NUM_MIDI_CHANNELS);
        Panelsmallgroups->show();
    }
    else
        Panelsmallgroups->hide();

    int oldswitch = channelswitch->value();
    channelswitch->value(synth->getRuntime().channelSwitchType);
    if (full)
    {
        oldswitch = channelswitch->value(); // disables 'pending'
        CS_CC = synth->getRuntime().channelSwitchCC;
    }
    if (synth->getRuntime().channelSwitchType > MIDI::SoloType::Disabled)
    {
        if (oldswitch == MIDI::SoloType::Disabled)
        {
            CSspinner->value(115);
            CSpend->show();
        }
        else
        {
            CSspinner->value(synth->getRuntime().channelSwitchCC);
            CSpend->hide();
        }
        CSspinner->show();
    }
    else
    {
        synth->getRuntime().channelSwitchCC = 128;
        CSspinner->hide();
        CSpend->hide();
    }
    panelwindow->changed();} {}
  }
  Function {partSwitch(int next)} {} {
    code {//
    if (npart != next)
    {
        npartcounter->value(next + 1);
        npartcounter->redraw();
        updatelistitem(npart); // deselect old one
        npart = next;
    }
    updatelistitem(next); // select and/or modify
    activePart = npart;
    partui->rebuild(npart);

    partEnable->value(synth->part[npart]->Penabled == 1);
    if (partEnable->value() == 1)
        partControls->activate();
    else
        partControls->deactivate();
    refreshControls(npart);
    masterwindow->redraw();} {}
  }
  Function {updateEngines(int engine, string instrumentName)} {} {
    code {//
        if (engine & 1) // addsynth
        instrumentaddbox->color(add_back);
    else
        instrumentaddbox->color(instr_back);

    if (engine & 2) // subsynth
        instrumentsubbox->color(sub_back);
    else
        instrumentsubbox->color(instr_back);

    if (engine & 4) // padsynth
        instrumentpadbox->color(pad_back);
    else
        instrumentpadbox->color(instr_back);

    instrumentaddbox->damage(1);
    instrumentsubbox->damage(1);
    instrumentpadbox->damage(1);
    instrumentlabel->copy_label(instrumentName.c_str());
    instrumentlabel->damage(1);

    if (npart >= panelgroup && npart < (panelgroup + NUM_MIDI_CHANNELS))
    {
        int num = npart % NUM_MIDI_CHANNELS;
        if (engine & 1)
            panellistitem[num]->partadd->color(add_back);
        else
            panellistitem[num]->partadd->color(FL_BACKGROUND_COLOR);
        if (engine & 2)
            panellistitem[num]->partsub->color(sub_back);
        else
            panellistitem[num]->partsub->color(FL_BACKGROUND_COLOR);
        if (engine & 4)
            panellistitem[num]->partpad->color(pad_back);
        else
            panellistitem[num]->partpad->color(FL_BACKGROUND_COLOR);

        panellistitem[num]->partadd->damage(1);
        panellistitem[num]->partsub->damage(1);
        panellistitem[num]->partpad->damage(1);
        panellistitem[num]->partname->copy_label(instrumentName.c_str());
    }} {}
  }
  Function {updateModepatch(bool inactive)} {} {
    code {//
        if (inactive)
            modepatch->color(warning_background);
        else
            modepatch->color(FL_BACKGROUND_COLOR);
        modepatch->redraw();} {}
  }
  Function {updatepart()} {} {
    code {//
    if (checkmaxparts())
    {
        if (npart >= partmax)
        {
            npart %= NUM_MIDI_CHANNELS;
            npart += (partmax - NUM_MIDI_CHANNELS);
            npartcounter->value(npart + 1);
            npartcounter->do_callback();
        }
        maxparts->value(partmax);
        maxparts->redraw();
        return;
    }

    partEnable->value(synth->partonoffRead(npart));

    maxparts->value(partmax);
    maxparts->redraw();
    npartcounter->value(npart + 1);
    activePart = npart;
    npartcounter->redraw();
    refreshControls(npart);} {}
  }
  Function {refreshControls(int npart)} {} {
    code {//
    partVol->value(synth->part[npart]->Pvolume);
    partVol->selection_color(setKnob(partVol->value(),96));
    partPan->value(synth->part[npart]->Ppanning);
    partPan->selection_color(setKnob(partPan->value(),64));
    partVelOffset->value(synth->part[npart]->Pveloffs);
    partVelOffset->selection_color(setKnob(partVelOffset->value(),64));
    partVelSense->value(synth->part[npart]->Pvelsns);
    partVelSense->selection_color(setKnob(partVelSense->value(),64));
    partui->setinstrumentlabel();
    partMidiCh->value(synth->part[npart]->Prcvchn + 1);
    partKeyLimit->value(synth->part[npart]->Pkeylimit);
    partKeyShift->value(synth->part[npart]->Pkeyshift - 64);
    minKeyCount->value(synth->part[npart]->Pminkey);
    maxKeyCount->value(synth->part[npart]->Pmaxkey);
    partPortamento->value(synth->part[npart]->ctl->portamento.portamento);

    sysEff1->value(synth->Psysefxvol[0][npart]);
        sysEff1->selection_color(setKnob(sysEff1->value(),0));
    sysEff2->value(synth->Psysefxvol[1][npart]);
        sysEff2->selection_color(setKnob(sysEff2->value(),0));
    sysEff3->value(synth->Psysefxvol[2][npart]);
        sysEff3->selection_color(setKnob(sysEff3->value(),0));
    sysEff4->value(synth->Psysefxvol[3][npart]);
        sysEff4->selection_color(setKnob(sysEff4->value(),0));

    int tmp = synth->ReadPartKeyMode(npart);
    if (tmp > PART_MONO)
        partKeymode->value(PART_LEGATO);
    else
        partKeymode->value(tmp);
    updateModepatch(tmp > PART_MONO && synth->part[npart]->Pdrummode != 0);

    partui->checkEngines();} {}
  }
  Function {updatepartprogram(int next)} {} {
    code {//
    if (vectorui)
        vectorui->setInstrumentLabel(next);

    if (partui->part->Prcvchn <  NUM_MIDI_CHANNELS)
    {
        partMidiCh->value(partui->part->Prcvchn + 1);
        partMidiCh->textcolor(gen_text);
    }
    else
    {
        //partMidiCh->textcolor(midi_solo_release);
        partMidiCh->textcolor(gen_text);
        partMidiCh->redraw();
    }
    partSwitch(next);} {}
  }
  Function {setMasterLabel(string name)} {} {
    code {//
        string spacer = "";
        if (!name.empty())
            spacer = " - ";
        masterwindow->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push(name), UNUSED, TOPLEVEL::windowTitle)).c_str());
        panelwindow->copy_label(textMsgBuffer.fetch(collect_readData(synth, textMsgBuffer.push("Mixer Panel" + spacer + name), UNUSED, TOPLEVEL::windowTitle)).c_str());
        masterwindow->changed();} {}
  }
  Function {do_load_scale(string fname)} {} {
    code {//
    send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedScale, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(fname));} {}
  }
  Function {do_load_instrument(string fname)} {} {
    code {//
    int npart = partui->npart;
    if ((npart /  NUM_MIDI_CHANNELS) == (panelgroup  /  NUM_MIDI_CHANNELS))
    {
        int displaypart = npart % NUM_MIDI_CHANNELS;
        panellistitem[displaypart]->partenabled->value(0);
        panellistitem[displaypart]->panellistitemgroup->deactivate();
    }
    partEnable->value(0);
    send_data(TOPLEVEL::action::forceUpdate, MAIN::control::loadInstrumentByName, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, npart, UNUSED, UNUSED, textMsgBuffer.push(fname));} {}
  }
  Function {do_load_master(string filename)} {} {
    code {//
    if (filename.empty())
    {
        filename = setfiler("", "", false, TOPLEVEL::XML::Patch);
        if (filename.empty())
            return;
    }
    send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedPatchset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));} {}
  }
  Function {do_save_master()} {} {
    code {//
    string filename = setfiler("", "", true, TOPLEVEL::XML::Patch);
    if (filename.empty())
        return;
    send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedPatchset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));} {}
  }
  Function {refresh_master_ui(int type)} {} {
    code {//
    if (microtonalui) // not taking chances!
        delete microtonalui;
    partmax = synth->getRuntime().NumAvailableParts;
    maxparts->value(partmax);
    checkmaxparts();
    panning_law->value(fetchData(0, MAIN::control::panLawType, TOPLEVEL::section::main));

    npartcounter->value((synth->getRuntime().currentPart) + 1);
    int next = synth->getRuntime().currentPart;
    partSwitch(next);

    // resync to effect data from last push-update
    syseffnocounter->value(syseffectui->effNum() + 1);
    sysefftype->value(syseffectui->effType());
    syseffectui->refresh();

    refreshInsEffUI();

    sysinsgroup->value(SystemEffectsGrp);

    bool isDirty;
    SysEffOn->value(syseffectui->isEnabled());
    if (SysEffOn->value())
        sysefftype->activate();
    else
        sysefftype->deactivate();
    if (syseffectui->effType() > 0)
    {
        isDirty = syseffectui->isChanged();
        syseffectui->UpdatePresetColour(isDirty, sysefftype->value());
    }
    if (inseffectui->effType() > 0)
    {
        isDirty = inseffectui->isChanged();
        inseffectui->UpdatePresetColour(isDirty, insefftype->value());
    }

    showSysEfxUI();

    masterkeyshift->value(synth->Pkeyshift - 64);
    setBpmFallbackValue(synth->PbpmFallback);
    mastervolumedial->value(synth->Pvolume);
    mastervolumedial->selection_color(setKnob(synth->Pvolume,90));
    globalfinedetune->value(synth->microtonal.Pglobalfinedetune);
    globalfinedetune->selection_color(setKnob(synth->microtonal.Pglobalfinedetune,64));
    microtonalui = new MicrotonalUI(&synth->microtonal, synth);
    if (type & 0x80)
        setMasterLabel(textMsgBuffer.fetch((type >> 8) & UNUSED));
    updatesendwindow();
    updatepanel(type > 0);
    if (type != 5)
        vectorui->RefreshChans();
    mastermono->value(0);
    mastermono->label("Stereo");
    if (type == 0x14)
    {
        for (int i = 1; i < 6; ++i)
            configui->update_config(i);
    }} {}
  }
  Function {checkmaxparts()} {return_type bool
  } {
    code {//
    bool changed = false;
    if (panelgroup >= partmax)
    {
        panelgroup = 0;
        Panelgroups->value(0);
        Panelsmallgroups->value(0);
        changed = true;
    }
    npartcounter->range(1, partmax);
    if (npart >= partmax)
    {
        npartcounter->value(1);
        activePart = 0;
        changed = true;
    }
    return changed;} {}
  }
  Function {strategicRetreat(void)} {} {
    code {query("", "", "", "Bad things happened,\\nYoshimi strategically retreats.");} {}
  }
  Function {Log(string msg)} {} {
    code {yoshiLog->log(msg);} {}
  }
  Function {showSysEfxUI(void)} {private
  } {
    code {//
    inseffectui->hide();
    inseffectui->deactivate();
    inseffectuigroup->hide();
    inseffectuigroup->deactivate();

    syseffectui->activate();
    syseffectui->show();
    syseffectuigroup->activate();
    syseffectuigroup->show();
    lastmainW = 0;} {}
  }
  Function {showInsEfxUI(void)} {private
  } {
    code {//
    syseffectui->hide();
    syseffectui->deactivate();
    syseffectuigroup->hide();
    syseffectuigroup->deactivate();

    inseffectui->activate();
    inseffectui->show();
    inseffectuigroup->activate();
    inseffectuigroup->show();
    lastmainW = 0;} {}
  }
  Function {showSysEffSends()} {} {
    code {//
    int fetchW, fetchH, fetchX, fetchY, fetchO;
    loadWin(synth, fetchW, fetchH, fetchX, fetchY, fetchO, "Master-systemeffectsend");

    if(fetchW < syseffDW || fetchH < syseffDH)
    {
        fetchW = syseffDW;
        fetchH = syseffDH;
    }
    checkSane(fetchX, fetchY, fetchW, fetchH, syseffDW, syseffDH);

    syseffsendwindow->resize(fetchX, fetchY, fetchW, fetchH);
    syseffsendwindow->redraw();
    syseffsendwindow->show();
    syseffSeen = true;} {}
  }
  Function {setinspartlist()} {} {
    code {//
    inseffpart->clear();
    inseffpart->add("Master Out"); // 0
    inseffpart->add("Off");        // 1
    int size = synth->getRuntime().NumAvailableParts;
    for (int i = 0; i < size; ++i)
    {
        string num = string("00") + asString(i + 1);
        inseffpart->add((string("Part ") + asString(i + 1)).c_str());
    }
    int current = inseffectui? inseffectui->getInsertFxRouting() : 2;
    assert(current < size);
    inseffpart->value(current + 2);} {}
  }
  Function {getPresetsUi()} {return_type {PresetsUI *}
  } {
    code {//
    return presetsui;} {}
  }
  Function {resetPartsClip()} {} {
    code {//
    for (int i = 0; i < NUM_MIDI_CHANNELS; i++)
    {
        if (panellistitem[i] && panellistitem[i]->partVUMeter)
        {
            panellistitem[i]->partVUMeter->resetPart(true);
        }
    }} {}
  }
  Function {refreshInsEffUI()} {} {
    code {//
    insefftype->value(inseffectui->effType());
    inseffnocounter->value(inseffectui->effNum() + 1);
    int routing = inseffectui->getInsertFxRouting();
    inseffpart->value(routing + 2); // offset since -2 ≙ master-out and -1 ≙ disabled
    inseffectui->refresh();
    if (routing != -1)
    {
        insefftype->activate();
        inseffectui->activate();
        inseffectuigroup->activate();
    }
    else
    {
        insefftype->deactivate();
        inseffectui->deactivate();
        inseffectuigroup->deactivate();
    }} {}
  }
  Function {setState(string filename)} {} {
    code {//
    send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));} {}
  }
  Function {setPartActive(int _npart, bool active)} {} {
    code {//
    if (_npart == npart)
    {
        partEnable->value(active);
    }} {}
  }
  Function {setPanelPartVolWidget(int _npart, float _value)} {} {
    code {//
    panellistitem[_npart]->partvolume->value(_value);
    panellistitem[_npart]->partvolume->selection_color(setSlider(_value,96));} {}
  }
  Function {setPanelPartPanWidget(int _npart, float _value)} {} {
    code {//
    panellistitem[_npart]->partpanning->value(_value);
    panellistitem[_npart]->partpanning->selection_color(setKnob(_value,64));} {}
  }
  Function {setPartMidiWidget(int _npart, unsigned char _value)} {} {
    code {//
    if (_npart == npart)
        partMidiCh->value(_value);
    partMidiCh->textcolor(gen_text);} {}
  }
  Function {setPanelPartMidiWidget(int _npart, unsigned char _value)} {} {
    code {//
    panellistitem[_npart]->partrcv->value(_value);
    panellistitem[_npart]->partrcv->textcolor(gen_text);
    panellistitem[_npart]->partrcv->redraw();} {}
  }
  Function {setLogging(bool isConsole)} {} {
    code {//
    logenable = isConsole;
    if (logenable)
        yoshiLog->Show(synth);
    else if (yoshiLog->logConsole->visible())
        yoshiLog->Hide(synth);} {}
  }
  Function {setBpmFallbackValue(float value)} {return_type void
  } {
    code {bpmfallback->value(value);
// Force format to include up to two decimal spaces, but only if
// they are non-zero.
char tmp[50];
snprintf(tmp, sizeof(tmp), "%.2f", value);
size_t len = strlen(tmp);

// Use const char references, since Fl_Spinner does not make an
// internal copy.
const char *format = "%.2f";
if (tmp[len-1] == '0')
{
    format = "%.1f";
    if (tmp[len-2] == '0')
        format = "%.0f";
}
bpmfallback->format(format);} {}
  }
  Function {updateBankRootDirs()} {} {
    code {bankui->readbankcfg();} {}
  }
  Function {updatepaths(int type)} {} {
    code {//
    if (type == 0)
    {
        bankui->readbankcfg();
        bankui-> rescan_for_banks();
    }} {}
  }
  Function {getSynth()} {return_type {SynthEngine *}
  } {
    code {return synth;} {}
  }
  Function {loadWindowData()} {} {
    code {//
    int fetchW, fetchH, fetchX, fetchY, fetchO;

    if (lastSeen(synth, "Mixer") & 3)
        Showpanel();

    if (lastSeen(synth, "Bank-instrument"))
        bankui->ShowInst();

    loadWin(synth, fetchW, fetchH, fetchX, fetchY, fetchO, "Bank-bank");
    bankui->bankuiwindow->position(fetchX, fetchY);
    if (fetchO)
        bankui->Showbank();
    else
        bankui->bankuiwindow->hide();

    loadWin(synth, fetchW, fetchH, fetchX, fetchY, fetchO, "Bank-root");
    bankui->rootuiwindow->position(fetchX, fetchY);
    if (fetchO)
        bankui->ShowRoot();
    else
        bankui->rootuiwindow->hide();

    if (lastSeen(synth, "Midi-virtualkeyboard"))
        virkeyboard->ShowKbd();
    else
        virkeyboard->virkeyboardwindow->hide();

    if (lastSeen(synth, "Scales"))
        microtonalui->showScales();
    else
        microtonalui->microtonaluiwindow->hide();

    if (lastSeen(synth, "Midi-learn"))
        midilearnui->showLearn();
    else
        midilearnui->midilearnwindow->hide();

    if (lastSeen(synth, "Config"))
        configui->Show(synth); // this does some initialising
    else
        configui->configwindow->hide();

    if (lastSeen(synth, "System-log") & 1)
        yoshiLog->Show(synth);
    else if (yoshiLog->logConsole->visible())
        yoshiLog->Hide(synth);

    if (lastSeen(synth, "Vector"))
        vectorui->Show(synth);
    else
        vectorui->vectorwindow->hide();

     if (lastSeen(synth, "Part-effects"))
        partui->Showefx();
    else
        partui->partfx->hide();

    if (lastSeen(synth, "Part-controllers"))
        partui->Showctl();
    else
        partui->ctlwindow->hide();

    if (lastSeen(synth, "Part-aftertouch"))
        partui->ShowAT();
    else
        partui->aftertouchcontrol->hide();

    if (lastSeen(synth, "Part-ctlmidi"))
        partui->Showctlmidi();
    else
        partui->ctlmidi->hide();

    if (lastSeen(synth, "Part-kit"))
        partui->Showkit();
    else
        partui->instrumentkitlist->hide();

    if (lastSeen(synth, "Part-edit"))
        partui->Showedit();
    else
        partui->instrumenteditwindow->hide();} {}
  }
  Function {checkBuffer(void)} {} {
    code {//
            if (lastmainW < 0) // not ready yet!
                return;
            read_updates(synth);
            wincheck();} {}
  }
  Function {rescaleMain(void)} {} {
    code {//
            if (lastmainW < 0) // not ready yet!
                return;
            float ratio = Fl::w() / float(1024); // reference width
            if (ratio < 1.0f)
                ratio = 1.0f;


            int x, y, w, h;
            if (syseffSeen)
            {
                x = syseffsendwindow->x();
                y = syseffsendwindow->y();
                w = syseffDW * ratio;
                h = syseffDH * ratio;
                if ((x + w) > Fl::w())
                    x = Fl::w() - w;
                if ((y + h) > Fl::h())
                    y = Fl::h() - h;
                syseffsendwindow->resize(x, y, w, h);
            }

            // we always check the main window last
            x = masterwindow->x();
            y = masterwindow->y();
            w = mainDW * ratio;
            h = mainDH * ratio;
            if ((x + w) > Fl::w())
                x = Fl::w() - w;
            if ((y + h) > Fl::h())
                y = Fl::h() - h;
            masterwindow->resize(x, y, w, h);
            //std::cout << "Screen ratio " << ratio << std::endl;} {}
  }
  Function {wincheck()} {} {
    code {//
    /*
     * Below is a pragmatic method of making tooltips
     * fairly readable at all screen resolutions.
     * 768 is the reference height.
     */
        if (oldH != Fl::h())
        {
            int setsize = int((11.0f / 768.0f) * Fl::h());
            Fl_Tooltip::size(setsize);
            oldH = Fl::h();
            //std::cout << "tipset " << setsize << "  actual " <<  Fl_Tooltip::size() << std::endl;

            if (masterwindow->x() >= Fl::w() || masterwindow->y() >= Fl::h())
                Showmaster(); // ensure it's always visible
        }

    if (masterwindow->w() != lastmainW)
    {
        mainRtext();
        if (lastmainW < 3)
            ++lastmainW;
        else
            lastmainW = masterwindow->w();
    }

    if (yoshiLog->logConsole->visible())
        yoshiLog->consoleRtext();

    if (panelwindow->visible())
    {
        if (panelwindow->w() != lastpanelW)
        {
            panelRtext();
            lastpanelW = panelwindow->w();
        }
    }

    if (message->visible() && message->w() != lastmsgW)
    {
        msgRtext();
        lastmsgW = message->w();
        msgSeen = true;
    }

    if (syseffectui->visible())
    {
        int efftype = EFFECT::type::eq - EFFECT::type::none;
        if(sysefftype->value() == efftype)
        {
            if (lastsyseffeqW < 0.15f)
            {
                lastsyseffeqW += 0.01f;
            }
            else if (lastsyseffeqW != mainScale)
            {
                syseffectui->effRtext(mainScale, efftype);
                lastsyseffeqW = mainScale;
            }
        }
    }
    if (syseffectui != NULL)
    {
        if (syseffectui->filterwindow != NULL)
        {
            if (syseffectui->filterwindow->visible())
            {
                if (lastsysDynFiltW != syseffectui->filterwindow->w())
                {
                    syseffectui->filtRtext();
                    lastsysDynFiltW = syseffectui->filterwindow->w();
                }
            }
        }
    }

    if (inseffectui != NULL)
    {
        if(inseffectui->filterwindow != NULL)
        {
            if (inseffectui->filterwindow->visible())
            {
                if (lastinsDynFiltW != inseffectui->filterwindow->w())
                {
                    inseffectui->filtRtext();
                    lastinsDynFiltW = inseffectui->filterwindow->w();
                }
            }
        }
    }

    if (syseffsendwindow->visible() &&  syseffsendwindow->w() != lastsyseffW)
    {
        syseffRtext();
        lastsyseffW = syseffsendwindow->w();
    }

    if (vectorui->vectorwindow->visible())
        vectorui->vectorRtext();

    if (microtonalui->microtonaluiwindow->visible())
        microtonalui->scaleRtext();

    if (midilearnui->midilearnwindow->visible())
        midilearnui->learnRtext();

    if (virkeyboard->virkeyboardwindow->visible() && lastvirtW != virkeyboard->virkeyboardwindow->w())
    {
        virkeyboard->virtRtext();
        lastvirtW = virkeyboard->virkeyboardwindow->w();
    }

    if (aboutwindow->visible() && lastaboutW != aboutwindow->w())
    {
        aboutRtext();
        lastaboutW = aboutwindow->w();
    }

    if (paramsui->Recent->visible())
        paramsui->paramRtext();

    if (configui->configwindow->visible())
        configui->configRtext();

    if (configui->presets->visible())
        configui->presetsRtext();

    presetsui->UpresetsRtext();
    bankui->wincheck();
    partui->wincheck();} {}
  }
  Function {mainRtext()} {} {
    code {//

    mainScale = float(masterwindow->w() / mainDW);

    int size = int(10 * mainScale);
    int size11 = int(11 * mainScale);
    int size12 = int(12 * mainScale);
    int size14 = int(14 * mainScale);

    mastermenu->textsize(size12);

    // part insert controls
    partVol->labelsize(size);
    partPan->labelsize(size);
    partVelOffset->labelsize(size);
    partVelSense->labelsize(size);
    instrumentlabel->labelsize(size12);
    partEdit->labelsize(size12);
    partControllers->labelsize(size12);
    partMidiCCs->labelsize(size12);
    partMidiCh->labelsize(size11);
        partMidiCh->textsize(size11);
    partKeymode->textsize(size11);
        modepatch->labelsize(size11);
    partPortamento->labelsize(size11);
    minKeyCount->labelsize(size);
        minKeyCount->textsize(size11);
    maxKeyCount->labelsize(size);
        maxKeyCount->textsize(size11);
    setMinToLast->labelsize(size);
    setNormal->labelsize(size11);
    setMaxToLast->labelsize(size);
    partKeyShift->labelsize(size);
        partKeyShift->textsize(size11);
    partKeyLimit->labelsize(size);
        partKeyLimit->textsize(size11);

    sysEff1->labelsize(size);
    sysEff2->labelsize(size);
    sysEff3->labelsize(size);
    sysEff4->labelsize(size);
    sysEffName->labelsize(size);

    partEnable->labelsize(size14);

    mainreset->labelsize(size11);
    mainstop->labelsize(size11);
    mainvirtkeyb->labelsize(size11);
    mixerpanel->labelsize(size11);
    mainmidilearn->labelsize(size11);
    vectors->labelsize(size11);
    globalfinedetune->labelsize(size);
    mastervolumedial->labelsize(size);
    mastermono->labelsize(size11);
    masterkeyshift->labelsize(size);
    masterkeyshift->textsize(size12);
    bpmfallback->labelsize(size);
    bpmfallback->textsize(size12);

    InstBlurb->labelsize(size11);
    nextInst->labelsize(size11);
    valueInst->textsize(size11);
    cancelInst->labelsize(size11);
    SystemEffectsGrp->labelsize(size12);
    InsertionEffectsGrp->labelsize(size12);
    if (syseffectui->visible())
    {;
        syseffnocounter->labelsize(size11);
            syseffnocounter->textsize(size11);
        sysefftype->labelsize(size11);
            sysefftype->textsize(size11);

        SysEffOn->labelsize(size14);
        sysEffSend->labelsize(size11);
        sysCopy->labelsize(size11);
        sysPaste->labelsize(size11);
        syseffectui->effRtext(mainScale, sysefftype->value());
    }
    else
    {
        inseffnocounter->labelsize(size11);
            inseffnocounter->textsize(size11);
        insefftype->labelsize(size11);
            insefftype->textsize(size11);

        inseffpart->labelsize(size11);
            inseffpart->textsize(size11);
        insCopy->labelsize(size11);
        insPaste->labelsize(size11);
        inseffectui->effRtext(mainScale, insefftype->value());
    }
    npartcounter->labelsize(size11);
        npartcounter->textsize(size11);
    maxparts->labelsize(size11);
        maxparts->textsize(size11);

    panning_law->labelsize(size12);
        panning_law->textsize(size12);

    undo->labelsize(size11);
    redo->labelsize(size11);

    masterwindow->redraw();} {}
  }
  Function {panelRtext()} {} {
    code {//
    int w = panelwindow->w();
    int h = panelwindow->h();
    float dW;
    float dH;

    if (panelType == 1)
    {
        dW = w / float(PANEL_SINGLE_X);
        dH = h / float(PANEL_SINGLE_Y);

    }
    else
    {
        dW = w / float(PANEL_DUAL_X);
        dH = h / float(PANEL_DUAL_Y);
    }

    float dScale;

    if (dW < dH)
        dScale = dW;
    else
        dScale = dH;
    if (dScale < 0.2f)
        dScale = 0.2f;
    panelScale = dScale;
    if (panelType == 1)
    {
        for (int i = 0; i < 16; ++ i)
        {
            panellistitem[i]->resize((8 + (i * 64)) * dW, 12 * dH, 63 * dW, 268 * dH);
            panellistitem[i]->itemRtext(dScale);
        }

    }
    else
    {
        for (int i = 0; i < 8; ++ i)
        {
            panellistitem[i]->resize((8 + (i * 64)) * dW, 12 * dH, 63 * dW, 268 * dH);
            panellistitem[i]->itemRtext(dScale);
        }
        for (int i = 8; i < 16; ++ i)
        {
            panellistitem[i]->resize((8 + ((i - 8) * 64)) * dW, 290 * dH, 63 * dW, 268 * dH);
            panellistitem[i]->itemRtext(dScale);
        }

        towide->resize(335 * dW, (PANEL_DUAL_Y - 30) * dH, 130 * dW, 25 * dH);
        Panelsmallgroups->resize(5 * dW, (PANEL_DUAL_Y - 23) * dH, 86 * dW, 18 * dH);
        Panelgroups->resize(5 * dW, (PANEL_DUAL_Y - 23) * dH, 86 * dW, 18 * dH);
        CSspinner->resize(173 * dW, (PANEL_DUAL_Y - 23) * dH, 50 * dW, 18 * dH);
        CSpend->resize(227 * dW, (PANEL_DUAL_Y - 30) * dH, 74 * dW, 25 * dH);
        channelswitch->resize(95 * dW, (PANEL_DUAL_Y -23) * dH, 74 * dW, 18 * dH);
        Panelclose->resize((PANEL_DUAL_X - 55) * dW, (PANEL_DUAL_Y - 30) * dH, 50 * dW, 25 * dH);

    }

    int size12 = int(12 * dScale);
    int size14 = int(14 * dScale);
    towide->labelsize(size14);
    todeep->labelsize(size14);
    Panelgroups->labelsize(size12);
        Panelgroups->textsize(size12);
    Panelsmallgroups->labelsize(size12);
        Panelsmallgroups->textsize(size12);
    CSspinner->labelsize(size12);
        CSspinner->textsize(size12);
    CSpend->labelsize(size12);
    channelswitch->labelsize(size12);
        channelswitch->textsize(size12);
    Panelclose->labelsize(size14);

    panelwindow->redraw();} {}
  }
  Function {aboutRtext()} {} {
    code {//
    float dScale = aboutwindow->w() / float(aboutDW);

    int size11 = int(11 * dScale);
    int size12 = int(12 * dScale);

    about2->labelsize(size11);
    about3->labelsize(size11);
    about4->labelsize(size12);
    about5->labelsize(size11);
    cont2->labelsize(size12);
    cont3->labelsize(size12);
    aboutClose->labelsize(size11);
    about1->labelsize(int(18 * dScale));
    cont1->labelsize(int(15 * dScale));

    aboutwindow->redraw();
    saveWin(synth, aboutwindow->w(), aboutwindow->h(), aboutwindow->x(), aboutwindow->y(), true, "Master-about");} {}
  }
  Function {syseffRtext()} {} {
    code {//
    float dScale = syseffsendwindow->w() / float(syseffDW);

    int size = int(10 * dScale);

    syseffgroup->resize(int(9 * dScale), int(46 * dScale), int(109 * dScale), int(172 * dScale));
    syseffname->labelsize(size);



    syseffClose->labelsize(int(14 * dScale));
    syseff01->labelsize(size);
    syseff02->labelsize(size);
    syseff03->labelsize(size);
    syseff12->labelsize(size);
    syseff13->labelsize(size);
    syseff23->labelsize(size);
    syseffsendwindow->redraw();} {}
  }
  Function {queryRtext()} {} {
    code {//
    if (lastqueryW == querywindow->w())
        return;
    lastqueryW = querywindow->w();

    float dScale = querywindow->w() / float(queryDW);

    int size14 = int(14 * dScale);

    yesQ->labelsize(size14);
    noQ->labelsize(size14);
    cancelQ->labelsize(size14);
    textQ->labelsize(size14);
    typeQ->labelsize(int(40 * dScale));

    querywindow->redraw();} {}
  }
  Function {msgRtext()} {} {
    code {//
    float dScale = message->w() / float(msgDW);

    int size14 = int(14 * dScale);

    words->labelsize(12 * dScale);
    yesdoit->labelsize(size14);
    cancel->labelsize(size14);
    closebutton->labelsize(size14);

    message->redraw();
    saveWin(synth, message->w(), message->h(),  message->x(),  message->y(), true, "Master-message");} {}
  }
  Function {textinRtext()} {} {
    code {//
    if (lasttextW == textwindow->w())
        return;
    lasttextW = textwindow->w();

    float dScale = textwindow->w() / float(textinDW);

    int size14 = int(14 * dScale);

    textLine->labelsize(size14);
    textLine->textsize(size14);
    textwindow->redraw();} {}
  }
  Function {theme()} {} {
    code {//
        masterwindow->hide();
        masterwindow->show();
        if (yoshiLog->logConsole->visible())
        {
            yoshiLog->logConsole->hide();
            yoshiLog->logConsole->show();
        }
        if (panelwindow->visible())
        {
            panelwindow->hide();
            panelwindow->show();
        }
        if (message->visible())
        {
            message->hide();
            message->show();
        }
        if (syseffsendwindow->visible())
        {
            syseffsendwindow->hide();
            syseffsendwindow->show();
        }
        if (syseffectui != NULL)
        {
            if (syseffectui->filterwindow != NULL)
            {
                    if (syseffectui->filterwindow->visible())
                    {
                        syseffectui->filterwindow->hide();
                        syseffectui->filterwindow->show();
                    }
                    if(syseffectui->fwin_filterui)
                        syseffectui->fwin_filterui->theme();
            }

        }
        if (inseffectui != NULL)
        {
            if (inseffectui->filterwindow != NULL)
            {
                    if (inseffectui->filterwindow->visible())
                    {
                        inseffectui->filterwindow->hide();
                        inseffectui->filterwindow->show();
                    }
                    if(inseffectui->fwin_filterui)
                        inseffectui->fwin_filterui->theme();
            }
        }

        if (vectorui->vectorwindow->visible())
        {
            vectorui->vectorwindow->hide();
            vectorui->vectorwindow->show();
        }
        if (microtonalui->microtonaluiwindow->visible())
        {
            microtonalui->microtonaluiwindow->hide();
            microtonalui->microtonaluiwindow->show();
        }
        if (midilearnui->midilearnwindow->visible())
        {
            midilearnui->midilearnwindow->hide();
            midilearnui->midilearnwindow->show();
        }
        if (virkeyboard->virkeyboardwindow->visible())
        {
            virkeyboard->virkeyboardwindow->hide();
            virkeyboard->virkeyboardwindow->show();
        }
        if (aboutwindow->visible())
        {
            aboutwindow->hide();
            aboutwindow->show();
        }
        if (paramsui->Recent->visible())
        {
            paramsui->Recent->hide();
            paramsui->Recent->show();
        }
        if (configui->configwindow->visible())
        {
            configui->configwindow->hide();
            configui->configwindow->show();
        }
        if (configui->presets->visible())
        {
            configui->presets->hide();
            configui->presets->show();
        }
        bankui->theme();
        partui->theme();
        ;} {}
  }
  decl {SynthEngine *synth;} {public local
  }
  decl {ConfigUI *configui;} {public local
  }
  decl {ParametersUI *paramsui;} {public local
  }
  decl {VectorUI *vectorui;} {public local
  }
  decl {MidiLearnUI *midilearnui;} {public local
  }
  decl {BankUI *bankui;} {public local
  }
  decl {MicrotonalUI *microtonalui;} {public local
  }
  decl {VirKeyboard *virkeyboard;} {public local
  }
  decl {int npart;} {public local
  }
  decl {int activePart;} {public local
  }
  decl {int partmax;} {
    comment {This is only public for vector control} public local
  }
  decl {Panellistitem *panellistitem[NUM_MIDI_PARTS];} {public local
  }
  decl {ConsoleUI *yoshiLog;} {public local
  }
  decl {PresetsUI *presetsui;} {private local
  }
  decl {string panelwindowlabel} {private local
  }
  decl {int current_ID;} {private local
  }
  decl {int panelgroup;} {public local
  }
  decl {int CS_CC;} {private local
  }
  decl {string filename;} {private local
  }
  decl {int msgGroup;} {private local
  }
  decl {float mainDW;} {private local
  }
  decl {float mainDH;} {private local
  }
  decl {float mainScale;} {private local
  }
  decl {int panelType;} {private local
  }
  decl {float msgDW;} {private local
  }
  decl {float msgDH;} {private local
  }
  decl {bool msgSeen;} {private local
  }
  decl {float syseffDW;} {private local
  }
  decl {float syseffDH;} {private local
  }
  decl {bool syseffSeen;} {private local
  }
  decl {float panelScale;} {private local
  }
  decl {bool logenable;} {private local
  }
  decl {int aboutDW;} {private local
  }
  decl {int aboutDH;} {private local
  }
  decl {int queryDW;} {private local
  }
  decl {int queryDH;} {private local
  }
  decl {int lastqueryW;} {private local
  }
  decl {int textinDW;} {private local
  }
  decl {int textinDH;} {private local
  }
  decl {int lasttextW;} {private local
  }
  decl {string filerpath;} {private local
  }
  decl {string filerext;} {private local
  }
  decl {string filerfound;} {private local
  }
  decl {bool dosave;} {private local
  }
  decl {int extension;} {private local
  }
  decl {bool filerdone;} {private local
  }
  decl {int filerDW;} {private local
  }
  decl {int filerDH;} {private local
  }
  decl {int lastfilerW;} {private local
  }
  decl {int lastmainW} {private local
  }
  decl {int lastpanelW} {private local
  }
  decl {int lastmsgW} {private local
  }
  decl {int lastsyseffW} {private local
  }
  decl {float lastsyseffeqW} {private local
  }
  decl {int lastsysDynFiltW} {private local
  }
  decl {int lastinsDynFiltW} {private local
  }
  decl {int lastvirtW} {private local
  }
  decl {int lastaboutW} {private local
  }
  decl {int oldH} {private local
  }
  decl {int fileruseX;} {private local
  }
  decl {std::deque<FilerLine> filerlist;} {private local
  }
  decl {int lineno;} {private local
  }
  decl {string type_name;} {private local
  }
}
