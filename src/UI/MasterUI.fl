# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.h}
code_name {.cc}
comment {MasterUI.h} {not_in_source in_header
}

comment {MasterUI.cc} {in_source not_in_header
}

comment {Original ZynAddSubFX author Nasca Octavian Paul
Copyright (C) 2002-2005 Nasca Octavian Paul
Copyright 2009-2011, Alan Calvert
Copyright 2014-2019, Will Godfrey & others

This file is part of yoshimi, which is free software: you can redistribute
it and/or modify it under the terms of the GNU Library General Public
License as published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.

yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
later) for more details.

You should have received a copy of the GNU General Public License along with
yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
Street, Fifth Floor, Boston, MA  02110-1301, USA.

This file is a derivative of the ZynAddSubFX original.

} {selected in_source in_header
}

decl {\#include <string>} {public local
}

decl {\#include <iostream>} {public local
}

decl {\#include <fstream>} {public local
}

decl {\#include "UI/MiscGui.h"} {public local
}

decl {\#include "ADnoteUI.h"} {public local
}

decl {\#include "SUBnoteUI.h"} {public local
}

decl {\#include "EffUI.h"} {public local
}

decl {\#include "VirKeyboardUI.h"} {public local
}

decl {\#include "ConfigUI.h"} {public local
}

decl {\#include "BankUI.h"} {public local
}

decl {\#include "PartUI.h"} {public local
}

decl {\#include "MicrotonalUI.h"} {public local
}

decl {\#include "PresetsUI.h"} {public local
}

decl {\#include "ParametersUI.h"} {public local
}

decl {\#include "VectorUI.h"} {public local
}

decl {\#include "ConsoleUI.h"} {public local
}

decl {\#include "MasterMiscUI.h"} {public local
}

decl {\#include "Misc/SynthEngine.h"} {public local
}

decl {\#include "MidiLearnUI.h"} {public local
}

decl {\#include "Misc/FileMgrFuncs.h"
    using file::isRegularFile;
    using file::findLeafName;} {private local
}

decl {\#include "Misc/FormatFuncs.h"
    using func::string2uint;
    using func::asString;} {private local
}

decl {\#include "Misc/TextMsgBuffer.h"

    namespace { // Implementation details...
        TextMsgBuffer& textMsgBuffer = TextMsgBuffer::instance();
    }} {private local
}

class MasterUI {: {private GuiUpdates}
} {
  Function {MasterUI(SynthEngine *_synth)} {} {
    code {//
      synth = _synth;
      presetsui = NULL;
      ninseff = 0;
      nsyseff = 0;
      npart = 0;
      panelgroup = 0;
      for (int i = 0; i < NUM_SYS_EFX; ++i)
      {
          for (int j = 0; j < NUM_SYS_EFX; ++j)
              syseffsend[i][j] = NULL;
      }
      microtonalui = NULL;
      bankui = NULL;
      virkeyboard = NULL;
      configui = NULL;
      presetsui = NULL;
      paramsui = NULL;
      activePart = 0;
      yoshiLog = NULL;} {}
  }
  Function {~MasterUI()} {} {
    code {//
      saveWindowData();
      masterwindow->hide();
      aboutwindow->hide();
      delete aboutwindow;
      syseffsendwindow->hide();
      delete syseffsendwindow;
      panelwindow->hide();
      delete panelwindow;
      if (microtonalui)
      {
          microtonalui->Hide();
          delete microtonalui;
      }
      if (bankui)
      {
          bankui->Hide();
          delete bankui;
      }
      if (virkeyboard)
      {
          virkeyboard->Hide();
          delete virkeyboard;
      }
      if (configui)
      {
          configui->Hide();
          delete configui;
      }
      if (presetsui)
      {
          presetsui->Hide();
          delete presetsui;
      }
      if (paramsui)
      {
          paramsui->Hide();
          delete paramsui;
      }
      if (vectorui)
      {
          vectorui->Hide();
          delete vectorui;
      }
      if (midilearnui)
      {
          midilearnui->Hide();
          delete midilearnui;
      }

      if (yoshiLog)
      {
          yoshiLog->Hide();
          delete yoshiLog;
      }
      //if (instance == 0)
          //Fl::unlock();
      delete masterwindow;} {}
  }
  Function {Init(const char *_label)} {} {
    code {//
      instance = synth->getUniqueId();

      filename = synth->getRuntime().ConfigDir + "/" +synth->getRuntime().programCmd();
      if (instance > 0)
      {
          filename += ("-" + asString(instance));
      }
      partmax = synth->getRuntime().NumAvailableParts;
      filename += EXTEN::window;
      microtonalui = new MicrotonalUI(&synth->microtonal, synth);
      bankui = new BankUI(synth);
      virkeyboard = new VirKeyboard(synth);
      configui = new ConfigUI(synth);
      presetsui = new PresetsUI(synth);
      paramsui = new ParametersUI(synth);
      vectorui = new VectorUI(synth, bankui, paramsui);
      midilearnui = new MidiLearnUI(synth);
      yoshiLog = new ConsoleUI();
      openedit = false;

      make_window();
      loadWindowData();
      string starterror = "";
      if(synth->getIsLV2Plugin())
      {
          masterwindow->label(_label);
      }
      else
      {
          starterror = textMsgBuffer.fetch(0);
          setMasterLabel(synth->getRuntime().paramsLoad);
      }
      masterwindow->show();
      if (starterror.find("Could not") != std::string::npos)
          fl_alert("%s", starterror.c_str());

      // these don't have access to synth ->
      microtonalui->microtonaluiwindow->copy_label(synth->makeUniqueName("Scales").c_str());
      yoshiLog->logConsole->copy_label(synth->makeUniqueName("Console").c_str());

      if (panelO)
          mixerpanel->do_callback();
      if (instrumentsO)
          bankui->Show();
      if (banksO)
          bankui->bankuiwindow->show();
      if (presetsO)
          configui->presets->show();
      if (rootsO)
          bankui->rootuiwindow->show();
      if (scalesO)
          microtonalui->microtonaluiwindow->show();
      if (virkbdO)
          virkeyboard->Show();
      if (settingsO)
          configui->Show();
      if (yoshiLogO)
          yoshiLog->Show();
      if (vectorO)
          vectorui->Show();
      if (mlearnO)
          midilearnui->Show();
      if (controllersO)
          partui->ctlwindow->show();
      if (midictlO)
          partui->ctlmidi->show();
      if (inseditO)
          partui->instrumenteditwindow->show();
      //if (kitlistO)
          //partui->instrumentkitlist->show();
      //if (partfxO)
          //partui->partfx->show();
      if (NewWindows)
      {
          words->copy_label("As this is a first time start, please check 'Yoshimi->Settings' then save and restart. More information can be found in the manual.");
          message->show();
          message->position(masterwindow->x() + 36, masterwindow->y() + 170);
      }
      else if (synth->getRuntime().oldConfig)
      {
          string msg;
          msg = "Existing config older than V " + to_string(MIN_CONFIG_MAJOR) + "." + to_string(MIN_CONFIG_MINOR) + " \\nCheck settings, save and restart.";
          message->position(masterwindow->x() + masterwindow->w() / 2 - message->w() / 2, masterwindow->y() + masterwindow->h() / 2 - message->h() / 2);
          words->copy_label(msg.c_str());
          message->show();}} {}
  }
  Function {make_window()} {} {
    Fl_Window masterwindow {
      label {Yoshimi meets ZynAddSubFX}
      callback {//
      bool close = true;
      bool force = Fl::event_state(FL_CTRL);
      if (!force && synth->getRuntime().configChanged)
      {
          int r = fl_choice("Parameters Changed", "Save Changes", "Cancel", "Don't Save");
          switch (r)
          {
              case 0:
                  synth->getRuntime().configChanged = false;
                  // this seems backwards but it *always* saves.
                  // seeing configChanged makes it reload the old settings first.
                  break;
              case 2:
                  break;
              default:
                  close = false;
                  break;
          }
      }
      if (close)
      {
          if (force)
              firstSynth->getRuntime().exitType = FORCED_EXIT;
              /*
               * The above line shouldn't be necessary!
               * It works fine on jack but fails on ALSA.
               * My best guess is that ALSA shuts down so quickly
               * that one of the ringbuffers carrying the command
               * is deleted before it can be read.
               */
              //send_data(0, TOPLEVEL::control::forceExit, 0, UNUSED);

          synth->guiClosed(true);
      }}
      xywh {231 433 385 465} type Double labelfont 13 labelsize 12 hide xclass Yoshimi
    } {
      Fl_Box {} {
        xywh {279 28 103 85} box ENGRAVED_FRAME
      }
      Fl_Menu_Bar mastermenu {
        xywh {-7 0 395 25} labelsize 12 textsize 12
        class ClearMenuBar
      } {
        Submenu {} {
          label {&Yoshimi}
          xywh {0 0 96 20} labelsize 12
        } {
          MenuItem {} {
            label {&About...}
            callback {//
                    Contributors->hide();
                    aboutwindow->show();
                    aboutFirst->show();}
            tooltip {Copyright and version info} xywh {15 15 100 20} labelsize 12
          }
          MenuItem newinstanceid {
            label {&New instance...}
            callback {//
            if(synth->getIsLV2Plugin())
            {
                fl_alert("Start new instances from host");
                return;
            }
            if(synth->getUniqueId() != 0)
            {
                fl_alert("Only main instance can start others");
                return;
            }

            const char *sId = fl_input("Accept next, or enter desired instance id...", "next");
            if (sId == NULL)
                return;
            unsigned int forceId = 0;
            if (sId)
                forceId = string2uint(sId);
            send_data(TOPLEVEL::action::lowPrio, MAIN::control::startInstance, forceId, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
            xywh {0 0 31 21} labelsize 12
          }
          MenuItem {} {
            label {&Settings...}
            callback {configui->Show();}
            tooltip {View, change, save settings} xywh {25 25 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Reports...}
            callback {yoshiLog->Show();}
            xywh {0 0 34 20} labelsize 12
          }
          MenuItem {} {
            label {&View Manual}
            callback {//
            words->copy_label("Searching for the manual.");
          message->show();
          message->position(masterwindow->x() + 36, masterwindow->y() + 170);
            send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::openManualPDF, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
            return;}
            xywh {0 0 34 20} labelsize 12
          }
          MenuItem {} {
            label {E&xit}
            callback {masterwindow->do_callback();}
            xywh {10 10 100 20} labelsize 12
          }
        }
        Submenu Instruments {
          label {&Instruments}
          xywh {0 0 100 20} labelsize 12
          code0 {(void) o; // suppress warning}
          code1 {vector <string> listType = *synth->getHistory(TOPLEVEL::XML::Instrument);}
          code2 {if (listType.size() == 0) RecentInstruments->deactivate(); else RecentInstruments->activate();}
        } {
          MenuItem {} {
            label {S&how Stored...}
            callback {bankui->Show();}
            xywh {20 20 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Load External...}
            callback {//
                string lastname = synth->lastItemSeen(TOPLEVEL::XML::Instrument);
                if (lastname == "")
                    lastname = synth->getRuntime().userHome;
                const char *filename;
                string exten = "({*" + EXTEN::anyInst + "})";
                filename = fl_file_chooser("Load:", exten.c_str(), lastname.c_str(), 0);
                if (filename == NULL)
                    return;
                do_load_instrument(filename);}
            tooltip {Load an instrument (.xi*) file} xywh {30 30 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Save External...}
            callback {//
                if (synth->part[npart]->Pname == DEFAULT_NAME)
                {
                    fl_alert("Nothing to save!");
                    return;
                }
                string newname = synth->lastItemSeen(TOPLEVEL::XML::Instrument);
                if (newname == "")
                {
                    newname = synth->part[npart]->Pname;
                    if (newname < "!")
                        return;
                    newname = synth->getRuntime().userHome + newname;
                }
                const char *filename;
                string exten = "({*" + EXTEN::anyInst + "})";
                filename = fl_file_chooser("Save:", exten.c_str(), newname.c_str(), 0);
                if (filename == NULL)
                    return;
                if (isRegularFile(string(filename)))
                    if (fl_choice("The file exists. \\nOverwrite it?", NULL, "No", "Yes") < 2)
                        return;
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedInstrument, float(npartcounter->value() - 1), TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(string(filename)));
                return;}
            tooltip {Save current instrument to an .xi* file} xywh {20 20 100 20} labelsize 12
          }
          MenuItem RecentInstruments {
            label {&Recent Instruments...}
            callback {//
            paramsui->Recent->position(masterwindow->x() + masterwindow->w() - paramsui->Recent->w(),masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::Instrument);}
            xywh {10 10 34 21} labelsize 12
          }
          MenuItem {} {
            label {&Clear}
            callback {//
            if(fl_choice("Clear parameters of instrument %d ?", NULL, "No", "Yes", partui->npart + 1) > 1)
                send_data(TOPLEVEL::action::forceUpdate, PART::control::defaultInstrument,0, TOPLEVEL::type::Integer, partui->npart);}
            xywh {35 35 100 20} labelsize 12
          }
          MenuItem {} {
            label {S&earch...}
            callback {//
        if (!synth->getRuntime().checksynthengines)
        {
            fl_alert("'Show engines/types' must be checked in Mixer Panel");
            return;
        }
        bankui->B_search->do_callback();
        bankui->searchwin->show();}
            xywh {0 0 34 20} labelsize 12
          }
        }
        Submenu Parameters {
          label {&Patch Sets}
          xywh {0 0 70 20} labelsize 12
          code0 {(void) o; // suppress warning}
          code1 {vector <string> listType = *synth->getHistory(TOPLEVEL::XML::Patch);}
          code2 {if (listType.size() == 0) RecentParams->deactivate(); else RecentParams->activate();}
        } {
          MenuItem {} {
            label {S&how Patch Banks...}
            callback {//
            bankui->bankuiwindow->show();}
            xywh {30 30 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Load External...}
            callback {//
            do_load_master(NULL);}
            tooltip {Load a patch set (.xmz) file} xywh {0 0 34 21} labelsize 12
          }
          MenuItem Save {
            label {&Save External...}
            callback {//
            bool valid = false;
            for(int npart = 0; npart < NUM_MIDI_PARTS; npart ++)
                if (synth->part[npart]->Pname != DEFAULT_NAME)
                {
                    valid = true;
                    npart = NUM_MIDI_PARTS;
                }
            if (valid)
                do_save_master();
            else
                fl_alert("Nothing to save!");}
            tooltip {Save current parameters to an .xmz file} xywh {0 0 34 21} labelsize 12
          }
          MenuItem RecentParams {
            label {&Recent Sets...}
            callback {//
            paramsui->Recent->position(masterwindow->x() + masterwindow->w() - paramsui->Recent->w(),masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::Patch);}
            xywh {0 0 34 21} labelsize 12
          }
        }
        Submenu {} {
          label {Pat&hs}
          xywh {0 0 65 20} labelsize 12
        } {
          MenuItem {} {
            label {&Bank Root Dirs...}
            callback {//
            bankui->rootuiwindow->show();}
            xywh {30 30 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Preset Dirs...}
            callback {//
            configui->presets->show();}
            xywh {0 0 34 20} labelsize 12
          }
        }
        Submenu Scales {
          label {&Scales}
          tooltip {Clear all parameters to default settings} xywh {0 0 60 20} labelsize 12
          code0 {(void) o; // suppress warning}
          code1 {vector <string> listType = *synth->getHistory(TOPLEVEL::XML::Scale);}
          code2 {if (listType.size() == 0) RecentScale->deactivate(); else RecentScale->activate();}
        } {
          MenuItem {} {
            label {S&how Settings...}
            callback {//
            microtonalui->Show();}
            xywh {20 20 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Load...}
            callback {//
    string lastname = synth->lastItemSeen(TOPLEVEL::XML::Scale);
    if (lastname == "")
        lastname = synth->getRuntime().userHome;
    string exten = "({*" + EXTEN::scale + "})";
    const char *filename = fl_file_chooser("Load:", exten.c_str(), lastname.c_str(), 0);
    if (filename != NULL)
        do_load_scale(string(filename));}
            xywh {35 35 100 20} labelsize 12
          }
          MenuItem {} {
            label {&Save...}
            callback {//
                string lastname = synth->getLastfileAdded(TOPLEVEL::XML::Scale);
                if (lastname == "")
                    lastname = synth->getRuntime().userHome;

                char *filename;
                string exten = "({*" + EXTEN::scale + "})";
                filename = fl_file_chooser("Save:", exten.c_str(), lastname.c_str(), 0);
                if (filename == NULL)
                    return;
                filename = fl_filename_setext(filename, EXTEN::scale.c_str());
                if (isRegularFile(string(filename)))
                    if (fl_choice("The file exists. \\nOverwrite it?", NULL, "No", "Yes") < 2)
                        return;
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedScale, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(string(filename)));}
            xywh {25 25 100 20} labelsize 12
          }
          MenuItem RecentScale {
            label {&Recent Scales...}
            callback {//
            paramsui->Recent->position(masterwindow->x() + masterwindow->w() - paramsui->Recent->w(),masterwindow->y()+20);
paramsui->Show(TOPLEVEL::XML::Scale);}
            xywh {20 20 34 21} labelsize 12
          }
          MenuItem {} {
            label {&Clear}
            callback {\#
            if (fl_choice("Set scales to the defaults?", NULL, "No", "Yes") > 1)
            {
                synth->microtonal.defaults();
                synth->setAllPartMaps();
                if (NULL != microtonalui)
                    delete microtonalui;
                microtonalui = new MicrotonalUI(&synth->microtonal, synth);
                send_data(TOPLEVEL::action::forceUpdate, SCALES::control::clearAll, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::scales);
            }}
            xywh {0 0 34 20} labelsize 12
          }
        }
        Submenu {} {
          label {S&tate}
          xywh {0 0 60 20} labelsize 12
          code0 {(void) o; // suppress warning}
          code1 {vector <string> listType = *synth->getHistory(TOPLEVEL::XML::State);}
          code2 {if (listType.size() == 0) RecentState->deactivate(); else RecentState->activate();}
        } {
          MenuItem loadState {
            label {&Load...}
            callback {// for Alessandro
            string lastname = synth->lastItemSeen(TOPLEVEL::XML::State);
            if (lastname == "")
                lastname = synth->getRuntime().userHome;
            string exten = "({*" + EXTEN::state + "})";
            char *fle = fl_file_chooser("Load:", exten.c_str(), lastname.c_str(), 0);
            if (fle)
            {
                setState(fle);
                RecentState->activate();
            }
            else
                refresh_master_ui(0x80 | (textMsgBuffer.push(" ") << 8));}
            tooltip {Load session state} xywh {0 0 34 21} labelsize 12
          }
          MenuItem saveState {
            label {&Save...}
            callback {// for Alessandro
            string lastname = synth->getLastfileAdded(TOPLEVEL::XML::State);
            if (lastname == "")
                lastname = synth->getRuntime().userHome;
            string exten = "({*" + EXTEN::state + "})";
            char *fle = fl_file_chooser("Save:", exten.c_str(), lastname.c_str(), 0);
            if (fle)
            {
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(string(fle)));
                RecentState->activate();
            }}
            tooltip {Save session state} xywh {10 10 34 21} labelsize 12
          }
          MenuItem {} {
            label {Save as &Default}
            callback {//
                string name = synth->getRuntime().defaultStateName;
                name += ("-" + to_string(instance));
                send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(name + ".state"));}
            tooltip {Save as default state (if load default checked)} xywh {0 0 34 21} labelsize 12
          }
          MenuItem RecentState {
            label {&Recent States...}
            callback {//
            paramsui->Recent->position(masterwindow->x() + masterwindow->w() - paramsui->Recent->w(),masterwindow->y()+20);
            paramsui->Show(TOPLEVEL::XML::State);}
            xywh {10 10 34 21} labelsize 12
          }
        }
      }
      Fl_Group MasterControls {
        label {Master  }
        xywh {3 24 380 91} labeltype NO_LABEL labelsize 11 labelcolor 96 align 22
      } {
        Fl_Dial globalfinedetune {
          label Detune
          callback {//
          send_data(TOPLEVEL::action::lowPrio, MAIN::control::detune, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
          tooltip {Global Fine Detune} xywh {286 32 40 40} box ROUND_UP_BOX color 29 labelsize 10 maximum 127 step 1 value 64
          code0 {o->setValueType(VC_GlobalFineDetune);}
          code1 {o->value(synth->microtonal.Pglobalfinedetune);}
          class WidgetPDial
        }
        Fl_Button {} {
          label Reset
          callback {//
          bool wasCtrl = (Fl::event_state(FL_CTRL) != 0);
          if (fl_choice("Set *ALL* dynamic values to their defaults?", NULL, "No", "Yes") > 1)
          {
              if(wasCtrl || (Fl::event_state(FL_CTRL) != 0))
                  send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::masterResetAndMlearn, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);
              else
                  send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::masterReset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}}
          tooltip {Clear all dynamic settings
(+Ctrl includes MIDI-learn)} xywh {7 60 70 24} box PLASTIC_UP_BOX color 228 selection_color 32 labelfont 1 labelsize 11 align 16
        }
        Fl_Button {} {
          label {Stop!}
          callback {//
          send_data(TOPLEVEL::action::muteAndLoop, MAIN::control::stopSound, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
          tooltip {Cease all sound immediately!} xywh {7 30 70 24} box PLASTIC_UP_BOX color 88 selection_color 0 labelfont 1 labelsize 11 align 16
        }
        Fl_Dial mastervolumedial {
          label Volume
          callback {//
          send_data(0, MAIN::control::volume, o->value(), 0, TOPLEVEL::section::main);}
          tooltip {Master Volume} xywh {335 32 40 40} box ROUND_UP_BOX color 29 labelsize 10 maximum 127 step 1
          code0 {o->setValueType(VC_MasterVolume);}
          code1 {o->value(synth->Pvolume);}
          class WidgetPDial
        }
        Fl_Button {} {
          label {Virtual Keyboard}
          callback {//
          virkeyboard->Show();}
          tooltip {Virtual Keyboard} xywh {85 60 110 24} box PLASTIC_UP_BOX color 228 labelsize 11 labelcolor 32
        }
        Fl_Button mixerpanel {
          label {Mixer Panel}
          callback {//
          updatepanel();
          panelwindow->show();}
          tooltip {Mixer Panel Window} xywh {85 30 110 24} box PLASTIC_UP_BOX color 228 labelsize 11 labelcolor 32
        }
        Fl_Button {} {
          label {Midi Learn}
          callback {//
          midilearnui->Show();
          //yoshiLog->Show();}
          tooltip {Message Log} xywh {203 60 70 24} box PLASTIC_UP_BOX color 228 labelsize 11
          code0 {/*if (synth->getRuntime().toConsole == false){o->deactivate();yoshiLog->Hide();}*/}
        }
        Fl_Button vectors {
          label Vectors
          callback {//
          vectorui->Show();}
          tooltip {Vector Setup Window} xywh {203 30 70 24} box PLASTIC_UP_BOX color 228 labelsize 11 labelcolor 32
        }
      }
      Fl_Tabs sysinsgroup {
        label {System/Insert}
        callback {//
        if (o->value() == SystemEffectsGrp)
            showSysEfxUI();
        else if (o->value() == InsertionEffectsGrp)
            showInsEfxUI();}
        xywh {3 88 379 68} box PLASTIC_UP_BOX color 44 selection_color 221 labeltype NO_LABEL labelsize 12 align 5
      } {
        Fl_Group SystemEffectsGrp {
          label {  System Effects  }
          xywh {3 116 379 40} color 221 selection_color 31 labelfont 1 labelsize 12 align 4
        } {
          Fl_Spinner syseffnocounter {
            label Effect
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectNumber, o->value() - 1, TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, o->value() - 1);}
            xywh {40 126 36 20} labeltype NO_LABEL labelsize 11 align 0 maximum 4 textfont 1 textsize 11
            code0 {o->range(1, NUM_SYS_EFX);}
            code1 {o->value(nsyseff + 1);}
          }
          Fl_Choice sysefftype {
            label Type
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectType, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, nsyseff);}
            xywh {120 126 96 20} down_box BORDER_BOX labeltype NO_LABEL labelsize 10 align 16
            code0 {o->value(synth->sysefx[nsyseff]->geteffect());}
          } {
            MenuItem {} {
              label {No Effect}
              xywh {10 10 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Reverb
              xywh {20 20 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Echo
              xywh {30 30 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Chorus
              xywh {40 40 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Phaser
              xywh {50 50 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label AlienWah
              xywh {60 60 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Distortion
              xywh {70 70 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label EQ
              xywh {80 80 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label DynFilter
              xywh {90 90 100 20} labelfont 1 labelsize 10
            }
          }
          Fl_Check_Button SysEffOn {
            label On
            callback {//
            if (o->value())
                    sysefftype->activate();
                else
                    sysefftype->deactivate();
            send_data(0, EFFECT::sysIns::effectEnable, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::systemEffects, nsyseff);}
            xywh {247 129 16 15} down_box DOWN_BOX value 1 labelfont 1 labelsize 11 align 4
          }
          Fl_Button {} {
            label {Send to}
            callback {//
            syseffsendwindow->show();}
            xywh {275 126 62 20} box THIN_UP_BOX labelfont 1 labelsize 11 labelcolor 97
          }
          Fl_Button {} {
            label C
            callback {presetsui->copy(synth->sysefx[nsyseff]);}
            xywh {350 122 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
          }
          Fl_Button {} {
            label P
            callback {//
            presetsui->paste(synth->sysefx[nsyseff], syseffectui);
            synth->getRuntime().effectChange = TOPLEVEL::section::systemEffects + (nsyseff << 8); // temporary fix}
            xywh {350 137 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
          }
        }
        Fl_Group InsertionEffectsGrp {
          label { Insertion Effects }
          xywh {3 116 379 40} color 221 selection_color 31 labelfont 1 labelsize 12 labelcolor 33 align 4 hide
        } {
          Fl_Spinner inseffnocounter {
            label Effect
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectNumber, o->value() - 1, TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, o->value() - 1);}
            xywh {40 126 36 20} labeltype NO_LABEL labelsize 11 align 20 maximum 8 textfont 1 textsize 11
            code0 {o->range(1, NUM_INS_EFX);}
            code1 {o->value(ninseff + 1);}
          }
          Fl_Choice insefftype {
            label Type
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectType, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, ninseff);}
            xywh {120 126 96 20} down_box BORDER_BOX labeltype NO_LABEL labelsize 11 align 0 textsize 12
            code0 {o->value(synth->insefx[ninseff]->geteffect());}
            code1 {if (synth->Pinsparts[ninseff]== -1) o->deactivate();}
          } {
            MenuItem {} {
              label {No Effect}
              xywh {25 25 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Reverb
              xywh {35 35 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Echo
              xywh {45 45 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Chorus
              xywh {55 55 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Phaser
              xywh {60 60 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label AlienWah
              xywh {70 70 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label Distortion
              xywh {80 80 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label EQ
              xywh {90 90 100 20} labelfont 1 labelsize 10
            }
            MenuItem {} {
              label DynFilter
              xywh {100 100 100 20} labelfont 1 labelsize 10
            }
          }
          Fl_Choice inseffpart {
            label {To }
            callback {//
            send_data(TOPLEVEL::action::forceUpdate, EFFECT::sysIns::effectDestination, o->value() - 2, TOPLEVEL::type::Integer, TOPLEVEL::section::insertEffects, ninseff);}
            xywh {242 126 96 20} down_box BORDER_BOX labelfont 1 labelsize 10 textfont 1 textsize 11
            code0 {setinspartlist();}
            code3 {o->value(synth->Pinsparts[ninseff]+2);}
          } {}
          Fl_Button {} {
            label C
            callback {presetsui->copy(synth->insefx[ninseff]);}
            xywh {350 122 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
          }
          Fl_Button {} {
            label P
            callback {//
            presetsui->paste(synth->insefx[ninseff], inseffectui);
            synth->getRuntime().effectChange = TOPLEVEL::section::insertEffects + (ninseff << 8); // temporary fix}
            xywh {350 137 25 14} box THIN_UP_BOX color 179 labelfont 1 labelsize 11 labelcolor 7
          }
        }
      }
      Fl_Group syseffectuigroup {
        xywh {3 158 384 95} box FLAT_BOX color 48 labeltype NO_LABEL
        code0 {o->show();}
      } {
        Fl_Group syseffectui {
          xywh {3 158 384 95} labeltype NO_LABEL
          code0 {o->init(synth->sysefx[nsyseff], TOPLEVEL::section::systemEffects, nsyseff);o->activate();o->show();}
          class EffUI
        } {}
      }
      Fl_Group inseffectuigroup {
        xywh {3 158 384 95} box FLAT_BOX color 48
        code0 {o->hide();}
      } {
        Fl_Group inseffectui {
          xywh {3 158 379 95} color 52
          code0 {o->init(synth->insefx[ninseff], TOPLEVEL::section::insertEffects, ninseff);o->hide();}
          code1 {if (synth->Pinsparts[ninseff]== -1) o->deactivate();}
          class EffUI
        } {}
      }
      Fl_Group partuigroup {
        xywh {3 255 380 170} box ENGRAVED_FRAME
      } {
        Fl_Group partui {
          xywh {3 255 379 170} color 47
          code0 {o->init(synth->part[0],0,bankui);}
          code1 {o->show();}
          class PartUI
        } {}
      }
      Fl_Group {} {
        xywh {3 427 379 36} box DOWN_BOX color 43 labelsize 12
      } {
        Fl_Box vumeter {
          label {VU-Meter}
          xywh {3 429 379 34} color 48 selection_color 75
          code0 {o->init(-1, synth);}
          class VUMeter
        }
        Fl_Button {} {
          callback {vumeter->init(-1, synth);}
          tooltip {Click here to clear VU peak reading and overload warning.} xywh {5 430 376 30} box NO_BOX
        }
      }
      Fl_Button mastermono {
        label S
        callback {//
        int tmp = 1 -  o->value();
        o->value(tmp);
        if (tmp == 0)
            o->label("S");
        else
            o->label("M");
        send_data(0, MAIN::control::mono,  tmp, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Master Mono/Stereo switch} xywh {285 88 23 20} box PLASTIC_UP_BOX color 228 selection_color 130 labelfont 1 labelsize 11
        code0 {o->value(synth->masterMono);}
      }
      Fl_Spinner masterkeyshift {
        label Shift
        callback {//
        send_data(TOPLEVEL::action::lowPrio, MAIN::control::keyShift, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Shift pitch +/- N semitones} xywh {336 88 38 20} labelsize 10 minimum -36 maximum 36 textsize 10
        code0 {o->range(MIN_KEY_SHIFT, MAX_KEY_SHIFT);o->step(1.0);}
        code1 {o->value(synth->Pkeyshift - 64);}
      }
      Fl_Spinner npartcounter {
        label Part
        callback {//
        int nval = o->value() - 1;
        activePart = nval;
        send_data(TOPLEVEL::action::forceUpdate, MAIN::control::partNumber, nval, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        xywh {36 264 40 20} labelsize 11 when 6 minimum 0 maximum 127 textsize 11
        code0 {o->range(1.0, partmax);}
        code1 {o->value(synth->getRuntime().currentPart + 1);}
        code2 {bankui->init(o);}
      }
      Fl_Spinner maxparts {
        label of
        callback {//
        int tmp = o->value();
        if (tmp == 48)
        {
            if (partmax == 32)
                tmp = 64;
            else
                tmp = 32;
        }
        send_data(TOPLEVEL::action::forceUpdate, MAIN::control::availableParts, tmp, TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Set the number of available parts} xywh {93 264 40 20} labelsize 11 minimum 16 maximum 64 step 16 value 16 textsize 11
        code0 {o->value(partmax);}
      }
    }
    comment {line spaces in boxes below are critical} {in_source in_header
    }
    Fl_Window aboutwindow {
      label {About Yoshimi}
      xywh {46 64 365 290} type Double color 54 labelfont 13 labelsize 13 when 0 hide
    } {
      Fl_Group aboutFirst {
        xywh {0 0 365 290} hide
      } {
        Fl_Box {} {
          label {Yoshimi
meets
ZynAddSubFX}
          xywh {10 15 345 70} labelfont 9 labelsize 18 labelcolor 216 align 16 when 0
        }
        Fl_Box {} {
          label {Copyright 2002-2009, Nasca O. Paul and others
Copyright 2009-2011, Alan Calvert
Copyright 2012-2013, Jeremy Jongepier and others
Copyright 2014-2019, Will Godfrey and others
LV2 plugin Copyright 2014, Andrew Deryabin
Splash Image Copyright 2017, Jesper Lloyd}
          xywh {25 90 315 91} color 51 selection_color 30 labelfont 13 labelsize 11
        }
        Fl_Box {} {
          label {This is free software, and comes with ABSOLUTELY NO
WARRANTY; you may redistribute it and/or modify it
under the terms of GPL version 2, or (at your option)
any later version.}
          xywh {10 190 340 53} labelsize 11
        }
        Fl_Box {} {
          label { version}
          xywh {61 254 240 20} labelfont 1 labelsize 12 labelcolor 145
          code0 {//
            o->copy_label((string("Yoshimi version ")
                           + string( YOSHIMI_VERSION )).c_str());}
        }
        Fl_Button {} {
          label more
          callback {//
                 Contributors->show();
                 aboutFirst->hide();}
          tooltip {Yoshimi's little band of helpers} xywh {15 253 43 22} labelsize 11
        }
      }
      Fl_Group Contributors {
        xywh {5 5 355 280} box FLAT_BOX color 7 labelcolor 7 hide
      } {
        Fl_Box {} {
          label {Some people who have helped Yoshimi
 in various ways since
Alan Calvert started the project}
          xywh {12 8 340 57} color 7 labelfont 9 labelsize 15 labelcolor 4
        }
        Fl_Box {} {
          label {
          Chris Ahlstrom
          Kristian Amlie
          Jonathan Brickman
          Jeanette Claassen
          Rob Couto
          Andrew Deryabin
          Jörn Eichler
          Csaba Erdei
          James Fraser
          Will Godfrey
          Alexander Hirsch
          Jeremy Jongepier
          Iain King-Speir
          Tobias Kortkamp
          }
          xywh {25 70 155 200} labelsize 12
        }
        Fl_Box {} {
          label {
          Tito Latini
          Rainer Liffers
          Jesper Lloyd
          Lars Luthman
          Holger Marzen
          Lieven Moors
          Harry Nakos
          Iurie Nistor
          Stephen Parry
          Lorenzo Sutton
          Hermann Voßeler
          Nikita Zlobin


          }
          xywh {194 70 155 200} labelsize 12
        }
      }
      Fl_Button {} {
        label Close
        callback {//
        aboutwindow->hide();}
        xywh {305 253 43 22} box THIN_UP_BOX labelsize 11
      }
    }
    Fl_Window syseffsendwindow {
      label {Sys Send}
      xywh {4 20 120 250} type Double labelfont 13 labelsize 13 hide
    } {
      Fl_Scroll {} {
        xywh {10 45 107 170} box FLAT_BOX
        code0 {//
            for (int neff1 = 0; neff1 < NUM_SYS_EFX; neff1++)
                for (int neff2 = neff1 + 1; neff2 < NUM_SYS_EFX; neff2++)}
        code1 {{
                syseffsend[neff1][neff2] =
                    new SysEffSend(o->x()+(neff2 - 1) * 35, o->y() + 20 + neff1 * 52, 30, 30);
                syseffsend[neff1][neff2]->label("aaa");
                syseffsend[neff1][neff2]->init(neff1, neff2, synth);
                syseffsend[neff1][neff2]->setValueType(VC_FXSysSend);
            }}
      } {}
      Fl_Button {} {
        label Close
        callback {//
        syseffsendwindow->hide();}
        xywh {20 220 80 25} box THIN_UP_BOX
      }
      Fl_Box {} {
        label {Send system effect's output to other system effects}
        xywh {5 5 110 35} labelsize 10 align 192
      }
    }
    Fl_Window panelwindow {
      label {Yoshimi Mixer Panel}
      xywh {483 128 550 670} type Double labelfont 13 labelsize 13 hide
      code0 {//if (synth->getRuntime().single_row_panel) ;}
      code1 {o->copy_label(synth->makeUniqueName("Mixer Panel").c_str());}
    } {
      Fl_Pack Panelpack1 {
        xywh {8 10 533 286} type HORIZONTAL
        code0 {//
          for (int i = 0; i < 8; i++)
          {
              panellistitem[i] = new Panellistitem(0, 0, 70, 260, "");
              panellistitem[i]->init(i, bankui, synth);
          }}
        code1 {o->spacing(-3);}
      } {}
      Fl_Pack Panelpack2 {
        xywh {8 325 533 286} type HORIZONTAL
        code0 {//
            for (int i = 8; i < 16; i++)
            {
                 panellistitem[i] = new Panellistitem(0, 0, 70, 260, "");
                 panellistitem[i]->init(i, bankui, synth);
            }}
        code1 {o->spacing(-3);}
      } {}
      Fl_Button Panelclose {
        label Close
        callback {//
        panelwindow->hide();}
        xywh {482 646 55 25} box THIN_UP_BOX labelsize 13
      }
      Fl_Button {} {
        label {Change to 1 x 16}
        callback {//
        synth->getRuntime().single_row_panel = 1;
        updatepanel();}
        xywh {354 640 118 25} box THIN_UP_BOX labelsize 13
      }
      Fl_Button {} {
        label {Change to 2 x 8}
        callback {//
        synth->getRuntime().single_row_panel = 0;
        updatepanel();}
        xywh {821 319 116 25} box THIN_UP_BOX labelsize 13
      }
      Fl_Choice Panelgroups {
        label {Part Group}
        callback {//
        panelgroup = o->value() * NUM_MIDI_CHANNELS;
        Panelsmallgroups->value(o->value());
        updatepanel();}
        xywh {12 650 86 18} down_box BORDER_BOX labelsize 12 align 1 textsize 12
      } {
        MenuItem {} {
          label {1 to 16}
          xywh {0 0 34 20} labelsize 12
        }
        MenuItem {} {
          label {17 to 32}
          xywh {0 0 34 20} labelsize 12
        }
        MenuItem {} {
          label {33 to 48}
          xywh {0 0 34 20} labelsize 12
        }
        MenuItem {} {
          label {49 to 64}
          xywh {0 0 34 20} labelsize 12
        }
      }
      Fl_Choice Panelsmallgroups {
        label {Part Group}
        callback {//
        panelgroup = o->value() * NUM_MIDI_CHANNELS;
        Panelgroups->value(o->value());
        updatepanel();}
        xywh {12 650 86 18} down_box BORDER_BOX labelsize 12 align 1 textsize 12
      } {
        MenuItem {} {
          label {1 to 16}
          xywh {10 10 34 20} labelsize 12
        }
        MenuItem {} {
          label {17 to 32}
          xywh {10 10 34 20} labelsize 12
        }
      }
      Fl_Spinner CSspinner {
        label CC
        callback {//
        CSpend->show();}
        xywh {216 650 50 18} labelsize 12 align 1 minimum 0 maximum 127 value 115 textsize 12
        code0 {CS_CC = synth->getRuntime().channelSwitchCC;}
        code1 {if (CS_CC < 128) o->value(CS_CC); else o->value(115);}
      }
      Fl_Button CSpend {
        label Pending
        callback {//
        CS_CC = synth->getRuntime().channelSwitchCC;
        int candidate = CSspinner->value();
        if (candidate == CS_CC)
        {
            o->hide();
            return;
        }

        string name = synth->getRuntime().masterCCtest(candidate);
        if (!name.empty())
        {
            fl_alert("In use for %s",name.c_str());
            if (CS_CC < 128)
            {
                CSspinner->value(CS_CC);
                CSspinner->redraw();
            }

        }
        else
        {
            send_data(TOPLEVEL::action::forceUpdate, MAIN::control::soloCC, CSspinner->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);
        }}
        tooltip {Click to set} xywh {276 651 70 20} box PLASTIC_UP_BOX color 90 labelsize 12 hide
      }
      Fl_Choice channelswitch {
        label Solo
        callback {//
                send_data(TOPLEVEL::action::forceUpdate, MAIN::control::soloType, o->value(), TOPLEVEL::type::Integer, TOPLEVEL::section::main);}
        tooltip {Assign groups of parts to Ch 1, singly enabled by MIDI} xywh {125 650 74 18} down_box BORDER_BOX labelsize 12 align 1 textsize 12
        code1 {o->value(synth->getRuntime().channelSwitchType);}
        code2 {if (o->value() == 0) CSspinner->hide(); else CSspinner->show();}
        code3 {CS_CC = o->value();}
      } {
        MenuItem switchoff {
          label Off
          xywh {40 40 34 20} labelsize 12
        }
        MenuItem switchrow {
          label Row
          xywh {40 40 34 20} labelsize 12
        }
        MenuItem switchcolumn {
          label Column
          xywh {40 40 34 20} labelsize 12
        }
        MenuItem switchloop {
          label Loop
          xywh {0 0 34 20} labelsize 12
        }
        MenuItem switchtwoway {
          label TwoWay
          xywh {0 0 34 20} labelsize 12
        }
      }
    }
    Fl_Window message {
      label Yoshimi
      xywh {9 25 290 85} type Double labelsize 12 hide
      code0 {o->copy_label(synth->makeUniqueName("").c_str());}
    } {
      Fl_Box words {
        label {?}
        xywh {5 9 280 45} color 55 selection_color 55 labelfont 1 labelsize 12 align 149
      }
      Fl_Button {} {
        label Close
        callback {message->hide();}
        xywh {211 60 70 20}
      }
      Fl_Button cancel {
        label Cancel
        callback {//
        send_data(0, MIDILEARN::control::cancelLearn, 0, 3, TOPLEVEL::section::midiLearn);
        o->hide();}
        xywh {130 60 70 20} hide
      }
    }
  }
  Function {send_data(int action, int control, float value, int type, int part = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int miscmsg = UNUSED)} {} {
    code {//
        type |= TOPLEVEL::type::Write;
        /*
            The following variations are due to the way the section was built
            up over time. It really needs the whole lot expanding for the calls
            to natively include all parameters.
        */
        if (control == MAIN::control::loadInstrumentByName && part == TOPLEVEL::section::main && miscmsg < NO_MSG)
        {
            collect_data(synth, 0, action, type, control, part, engine, UNUSED, UNUSED, UNUSED, UNUSED, miscmsg);
            return;
        }

        if (control <= MAIN::control::soloType)
            type |= Fl::event_button();
        if (parameter == 0)
        {
            collect_data(synth, 0, action, type, control, part, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, miscmsg);
            return;
        }

        collect_data(synth, value, action, type, control, part, UNUSED, engine, insert, parameter, UNUSED, miscmsg);} {}
  }
  Function {fetchData(float value, int control, int part, int kititem = UNUSED, int engine = UNUSED, int insert = UNUSED, int parameter = UNUSED, int offset = UNUSED, int miscmsg = UNUSED, int request = UNUSED)} {return_type float
  } {
    code {//
        return collect_readData(synth, value, control, part, kititem, engine, insert, parameter, offset, miscmsg, request);} {}
  }
  Function {returns_update(CommandBlock *getData)} {} {
    code {//
    float value = getData->data.value.F;
    bool wasFromHere = ((getData->data.source & TOPLEVEL::action::noAction) == TOPLEVEL::action::fromGUI);
    unsigned char control = getData->data.control;
    unsigned char newpart = getData->data.part;
    unsigned char kititem = getData->data.kit;
    unsigned char engine = getData->data.engine;
    unsigned char insert = getData->data.insert;
    unsigned char parameter = getData->data.parameter;
    unsigned char miscmsg = getData->data.miscmsg;
    int value_int = lrint(value);
    int chan = kititem & 0x3f;
    bool isSingle = kititem >= 0x40;
    int mask = NUM_MIDI_CHANNELS - 1;

    if (newpart == TOPLEVEL::section::midiIn)
    {
        if (engine == MIDI::CC::volume && partui->part->ctl->volume.receive == 0)
            return; // disabled
        if (engine == MIDI::CC::expression && partui->part->ctl->expression.receive == 0)
            return; // disabled

        float vol = (value * synth->part[npart]->ctl->volume.data) / 127;
        if (control == MIDI::control::controller)
        { // panel entries only
            for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
            {
                if(panellistitem[i]->partenabled->value() != 0)
                {
                    if((isSingle && i == (chan & mask)
                                 && panellistitem[i]->partrcv->value() == (chan & mask)
                                 && (chan / NUM_MIDI_CHANNELS) == (panelgroup / NUM_MIDI_CHANNELS))
                         || (!isSingle && panellistitem[i]->partrcv->value() == (chan & mask)))
                    {
                        if (engine == MIDI::CC::volume)
                            panellistitem[i]->partvolume->value(vol);
                        else if (engine == MIDI::CC::panning)
                            panellistitem[i]->partpanning->value(value);
                    }
                }
            }
        }

        bool isForUs = (isSingle && chan == npart)
             || (!isSingle &&  (partui->midich->value() == (chan & mask) + 1));// && partui->partGroupEnable->value() != 0);
        switch(control)
        {
            case MIDI::control::noteOn:
            case MIDI::control::noteOff:
                break;
            case MIDI::control::controller:
                //cout << " Value " << value_int << "  kit " << int(kititem) << "  npart " << int(npart) << endl;
                if(engine <= 119 && engine == synth->getRuntime().channelSwitchCC)
                { // it's a valid channel switch
                    int newch = partui->midich->value() - 1;
                    switch (synth->getRuntime().channelSwitchType)
                    {
                        case 1: // row
                            if (npart < NUM_MIDI_CHANNELS)
                            {
                                if (npart != value_int)
                                    newch = NUM_MIDI_CHANNELS;
                                else
                                    newch = 0;
                            }
                            break;

                        case 2: // column
                            if(value_int == npart)
                                newch = (value_int & mask);
                            else if((value_int & mask) == (npart & mask))
                                newch = (value_int & mask) + NUM_MIDI_CHANNELS;
                            break;

                        case 3: // loop
                        case 4: // twoway
                            if (npart < NUM_MIDI_CHANNELS)
                            {
                                if (npart == synth->getRuntime().channelSwitchValue)
                                    newch = 0;
                                else if (value_int > 0)
                                    newch = NUM_MIDI_CHANNELS;
                            }
                            break;
                    }
                    partui->midich->value(newch + 1);

                    if (newch < NUM_MIDI_CHANNELS)
                        partui->midich->textcolor(FL_BLACK);
                    else
                        partui->midich->textcolor(FL_WHITE);
                    updatepanel();
                }
                else if (isForUs)
                {
                    switch(engine)
                    {
                        case MIDI::CC::modulation:
                            partui->modulation->value(value);
                            break;
                        case MIDI::CC::volume:
                            partui->partvol->value(vol);
                            break;
                        case MIDI::CC::panning:
                            partui->partpan->value(value);
                            break;
                        case MIDI::CC::expression:
                            partui->expression->value(value);
                            break;
                        case MIDI::CC::legato:
                        {
                            int mode = synth->ReadPartKeyMode(npart);
                            partui->legatoMode->labelcolor(FL_BLACK);
                            if (mode > 1)
                            {
                                partui->keymode->value(2);
                                if (partui->drumMode->value() != 0)
                                    partui->legatoMode->labelcolor(FL_RED);
                            }
                            else
                                partui->keymode->value(mode);
                            break;
                        }
                        case MIDI::CC::filterQ:
                            partui->filterq->value(value);
                            break;
                        case MIDI::CC::filterCutoff:
                            partui->filtercutoff->value(value);
                            break;
                        case MIDI::CC::bandwidth:
                            partui->masterbandwidth->value(value);
                            break;
                    }
                }
                break;
            case MIDI::control::bankChange:
                if (engine != UNUSED)
                    bankui->readbankcfg();
                bankui->rescan_for_banks(false);
                break;
        }
        return;
    }
    if (newpart == TOPLEVEL::section::systemEffects)
    {
        if (insert == TOPLEVEL::insert::systemEffectSend)
        {
            if (!wasFromHere)
                syseffsend[engine][control]->value(value);
        }
        else
        {
            if (control == EFFECT::sysIns::effectNumber)
            {
                syseffnocounter->value(engine + 1);
                nsyseff = engine;
                sysefftype->value(synth->sysefx[nsyseff]->geteffect());
                syseffectui->refresh(synth->sysefx[nsyseff], TOPLEVEL::section::systemEffects, nsyseff);
                syseffectui->UpdatePresetColour(parameter, sysefftype->value());
                SysEffOn->value(fetchData(0, EFFECT::sysIns::effectEnable, TOPLEVEL::section::systemEffects, UNUSED, 0));
                if (SysEffOn->value())
                    sysefftype->activate();
                else
                    sysefftype->deactivate();
            }
            else if (control == EFFECT::sysIns::effectType)
            {
                syseffnocounter->value(engine + 1);
                nsyseff = engine;
                sysefftype->value(value_int);
                syseffectui->refresh(synth->sysefx[nsyseff], TOPLEVEL::section::systemEffects, nsyseff);
                syseffectui->UpdatePresetColour(parameter, sysefftype->value());
                showSysEfxUI();
            }
            else if (control == EFFECT::sysIns::effectEnable)
            {
               SysEffOn->value(value_int);
               if (value_int)
                    sysefftype->activate();
                else
                    sysefftype->deactivate();
            }
        }
        return;
    }
    else if (newpart == TOPLEVEL::section::insertEffects)
    {
        if (control == EFFECT::sysIns::effectNumber)
        {
            ninseff = engine;
            setInsEff(ninseff);
            showInsEfxUI();
            inseffectui->UpdatePresetColour(parameter, insefftype->value());

        }
        else if (control == EFFECT::sysIns::effectType)
        {
            inseffnocounter->value(engine + 1);
            ninseff = engine;
            insefftype->value(value_int);
            setInsEff(ninseff);
            inseffectui->UpdatePresetColour(parameter, insefftype->value());
            showInsEfxUI();
        }
        else if (control == EFFECT::sysIns::effectDestination)
        {
            inseffpart->value(value_int + 2);
            if (value_int == -1)
                insefftype->deactivate();
            else
            {
                insefftype->activate();
                setInsEff(ninseff);
                showInsEfxUI();
            }
        }
        return;
    }
    string name;
    switch(control)
    {
        case MAIN::control::volume:
            mastervolumedial->value(value);
            break;

        case MAIN::control::partNumber:
            if ((getData->data.source & TOPLEVEL::action::noAction) != TOPLEVEL::action::fromGUI)
                activePart = value_int;
            partuigroup->remove(partui);
            delete partui;
            partui = new PartUI(0, 0, 765, 525);
            partuigroup->add(partui);
            partui->init(synth->part[activePart], activePart, bankui);
            partui->redraw();
            partui->npart = activePart;
            npartcounter->value(activePart + 1);
            npartcounter->redraw();
            updatepanel();
            if (openedit)
            {
                partui->instrumenteditwindow->show();
                openedit = false;
            }
            break;

        case MAIN::control::availableParts:
            partmax = value_int;
            npartcounter->range(1, partmax);
            updatepart();
            updatepanel();
            setinspartlist();
            vectorui->checkParts(value_int);
            break;

        case MAIN::control::detune:
            globalfinedetune->value(value);
            break;

        case MAIN::control::keyShift:
            masterkeyshift->value(value_int);
            break;

        case MAIN::control::mono:
            mastermono->value(value_int);
            if (value_int)
                mastermono->label("M");
            else
                mastermono->label("S");
            break;


        case MAIN::control::soloType:
            channelswitch->value(value_int);
            if (value_int == 0)
            {
                CS_CC = 128;
                CSspinner->value(115); // default
                CSspinner->hide();
                CSpend->hide();
                for (int i = 0; i < NUM_MIDI_CHANNELS; ++i)
                    setPanelPartMidiWidget(i, i);
            }
            else
            {
                CS_CC = 115;
                CSspinner->value(115);
                CSpend->show();
                CSspinner->show();
                for (int i = 1; i < NUM_MIDI_CHANNELS; ++i)
                {
                    if (value_int == 2)
                        setPanelPartMidiWidget(i, i);
                    else
                        setPanelPartMidiWidget(i, 16);
                }
            }
            panelwindow->changed();
            break;
        case MAIN::control::soloCC:
            updatepanel();
            break;
        case MAIN::control::exportBank:
            name = textMsgBuffer.fetch(miscmsg);
            if (wasFromHere)
                fl_alert("%s",name.c_str());
            break;
        case MAIN::control::importBank: // import bank
            name = textMsgBuffer.fetch(miscmsg);
            if (wasFromHere)
            {
                if (name.find("FAILED") == 1)
                    fl_alert("%s",name.c_str());
                else
                {
                    unsigned int other = name.find(" : ");
                    if (other < 1024) // a bit of a hack :(
                    {
                        name = name.substr(other + 3);
                        fl_alert("%s",name.c_str());
                    }
                }
            }
            bankui->rescan_for_banks(false);
            break;
        case MAIN::control::deleteBank: // delete bank and contents
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            bankui->rescan_for_banks(false);
            bankui->set_bank_slot();
            break;

        case MAIN::control::loadInstrumentFromBank:
            if (insert != UNUSED)
            {
                ;// updateBankRootDirs() // apparently not needed!
            }
            if (engine != UNUSED)
                bankui->readbankcfg();
            if (insert != UNUSED || engine != UNUSED)
                bankui->rescan_for_banks(false);
            updatepartprogram(kititem);
            break;

        case MAIN::control::loadInstrumentByName:
            updatepartprogram(kititem);
            RecentInstruments->activate();
            break;

        case MAIN::control::saveNamedInstrument: // save instrument
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                partui->setinstrumentlabel();
                panellistitem[newpart % NUM_MIDI_CHANNELS]->refresh();
                RecentInstruments->activate();
            }
            break;

        case MAIN::control::loadNamedPatchset: // load patchset
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                vectorui->RefreshChans();
                RecentParams->activate();
                setMasterLabel(findLeafName(name));
                refresh_master_ui(2);
            }

            break;

        case MAIN::control::saveNamedPatchset: // save patch set
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                setMasterLabel(findLeafName(name));
                RecentParams->activate();
                updatepanel(); // why?
            }
            break;

        case MAIN::control::loadNamedVector: // load vector
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                vectorui->setLoadLabelRemote(insert, synth->getRuntime().vectordata.Name[insert]);
                setMasterLabel(findLeafName(name) + " - Vector " + to_string(int(insert) + 1));
                vectorui->recenthistory->activate();
                refresh_master_ui(5);
            }
            break;

        case MAIN::control::saveNamedVector: // save vector
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                setMasterLabel(findLeafName(name) + " - Vector " + to_string(int(insert) + 1));
                vectorui->recenthistory->activate();
            }
            break;

        case MAIN::control::loadNamedScale: // load scales
            name = textMsgBuffer.fetch(miscmsg);
            if (name.find("FAILED") == 1)
            {
                if (wasFromHere)
                    fl_alert("%s",name.c_str());
            }
            else
            {
                RecentScale->activate();
                microtonalui->Hide();
                microtonalui->make_window();
            }
            break;

        case MAIN::control::saveNamedScale: // save scales
            name = textMsgBuffer.fetch(miscmsg);
            if (wasFromHere && name.find("FAILED") == 1)
                fl_alert("%s",name.c_str());
            else
                RecentScale->activate();
            break;

        case MAIN::control::loadNamedState: // load state
            name = textMsgBuffer.fetch(miscmsg);
            if (wasFromHere && name.find("FAILED") == 1)
            {
                fl_alert("%s",name.c_str());
                refresh_master_ui(1);
            }
            else
            {
                setMasterLabel(findLeafName(name) + " - State");
                refresh_master_ui(0x14);
            }
            break;

        case MAIN::control::saveNamedState: // save state
            name = textMsgBuffer.fetch(miscmsg);
            if (wasFromHere && name.find("FAILED") == 1)
                fl_alert("%s",name.c_str());
            else
                setMasterLabel(findLeafName(name) + " - State");
            break;

        case MAIN::control::masterReset:
            if (newpart == TOPLEVEL::section::main)
            {
                refresh_master_ui(1);
                vumeter->init(-1, synth);
                resetPartsClip();
            }
            else if (newpart < NUM_MIDI_PARTS)
                partNew(newpart);
            setMasterLabel("");
            break;

        case MAIN::control::masterResetAndMlearn:
            refresh_master_ui(1);
            resetPartsClip();
            if (midilearnui)
                midilearnui->Hide();
            setMasterLabel("");
            break;

        case MAIN::control::openManualPDF:
            message->hide();
            if (miscmsg != NO_MSG)
                fl_alert("%s", textMsgBuffer.fetch(miscmsg).c_str());
            break;

        case MAIN::control::startInstance: // new instance (do nothing here)
            break;

        case MAIN::control::stopSound:
            virkeyboard->relaseallkeys();
            vumeter->init(-1, synth);
            resetPartsClip();
            break;
    }} {}
  }
  Function {updatesendwindow()} {} {
    code {//
    for (int neff1 = 0; neff1 < NUM_SYS_EFX; ++neff1)
        for (int neff2 = neff1 + 1; neff2 < NUM_SYS_EFX; ++neff2)
            syseffsend[neff1][neff2]->value(synth->Psysefxsend[neff1][neff2]);} {}
  }
  Function {updatelistitem(int part)} {} {
    code {//
    int tmp = part % NUM_MIDI_CHANNELS;
    panellistitem[tmp]->refresh();} {}
  }
  Function {updatepanel(bool full = false)} {} {
    code {//
    if (synth->getRuntime().single_row_panel)
    {
            panelwindow->size(1085,350);
            Panelpack2->position(544,10);
            Panelclose->position(1018,319);
            Panelgroups->position(12,327);
            Panelsmallgroups->position(12,327);
            channelswitch->position(130,327);
            CSspinner->position(216,327);
            CSpend->position(276,325);
    }
    else
    {
            panelwindow->size(550,670);
            Panelpack2->position(8,325);
            Panelclose->position(482,639);
            Panelgroups->position(12,645);
            Panelsmallgroups->position(12,645);
            channelswitch->position(130,645);
            CSspinner->position(216,645);
            CSpend->position(275,643);
    }

    for (int npart = 0; npart < partmax; ++npart)
    {
        if (npart < NUM_MIDI_CHANNELS)
            panellistitem[npart]->refresh();
        vectorui->setInstrumentLabel(npart);
    }

    if (partmax == 64)
        Panelgroups->show();
    else
        Panelgroups->hide();
    if (partmax == 32)
        Panelsmallgroups->show();
    else
        Panelsmallgroups->hide();

    int oldswitch = channelswitch->value();
    channelswitch->value(synth->getRuntime().channelSwitchType);
    if (full)
    {
        oldswitch = channelswitch->value(); // disables 'pending'
        CS_CC = synth->getRuntime().channelSwitchCC;
    }
    if (synth->getRuntime().channelSwitchType > 0)
    {
        if (oldswitch == 0)
        {
            CSspinner->value(115);
            CSpend->show();
        }
        else
        {
            CSspinner->value(synth->getRuntime().channelSwitchCC);
            CSpend->hide();
        }
        CSspinner->show();
    }
    else
    {
        synth->getRuntime().channelSwitchCC = 128;
        CSspinner->hide();
        CSpend->hide();
    }
    panelwindow->changed();} {}
  }
  Function {updateEngines(bool isOn)} {} {
    code {//
        bankui->rescan_for_banks(true);
        bankui->enginecheck->value(isOn);
        if (isOn)
            bankui->B_search->activate();
        else
            bankui->B_search->deactivate();
        partui->checkEngines();
        updatepanel();} {}
  }
  Function {partNew(int _npart)} {} {
    code {//
    int nval = _npart;
    partuigroup->remove(partui);
    delete partui;
    partui = new PartUI(0, 0, 765, 525);
    partuigroup->add(partui);
    partui->init(synth->part[nval], nval, bankui);
    partui->redraw();
    npartcounter->value(nval + 1);
    npartcounter->redraw();
    updatelistitem(npart);
    updatelistitem(nval);
    activePart = nval;
    npart = nval;} {}
  }
  Function {updatepart()} {} {
    code {//
    if (checkmaxparts())
    {
        npart = 0;
        npartcounter->value(npart + 1);
        npartcounter->do_callback();
        maxparts->value(partmax);
        maxparts->redraw();
        return;
    }

    if (synth->partonoffRead(npart))
        partui->partgroupui->activate();
    else
        partui->partgroupui->deactivate();

    partui->partGroupEnable->value(synth->partonoffRead(npart));
    partui->partpan->value(synth->part[npart]->Ppanning);
    partui->partvol->value(synth->part[npart]->Pvolume);
    partui->partkeylimit->value(synth->part[npart]->Pkeylimit);
    partui->velocitysense->value(synth->part[npart]->Pvelsns);
    partui->velocityoffset->value(synth->part[npart]->Pveloffs);
    partui->partkeyshift->value(synth->part[npart]->Pkeyshift - 64);
    partui->minkcounter->value(synth->part[npart]->Pminkey);
    partui->maxkcounter->value(synth->part[npart]->Pmaxkey);
    partui->enportamento->value(synth->part[npart]->ctl->portamento.portamento);

    partui->keymode->value(synth->part[npart]->Pkeymode & MIDI_NOT_LEGATO);

    maxparts->value(partmax);
    maxparts->redraw();
    npartcounter->value(npart + 1);
    activePart = npart;
    npartcounter->redraw();
    partui->checkEngines();} {}
  }
  Function {updatepartprogram(int _npart)} {} {
    code {//
    if (vectorui)
        vectorui->setInstrumentLabel(_npart);
    /*if (_npart != npart) // not needed?
    {
        updatelistitem(_npart);
        return;
    }*/

    if (partui->part->Prcvchn <  NUM_MIDI_CHANNELS)
    {
        partui->midich->value(partui->part->Prcvchn + 1);
        partui->midich->textcolor(FL_BLACK);
    }
    else
    {
         partui->midich->textcolor(FL_WHITE);
         partui->midich->redraw();
    }
    partNew(_npart);} {}
  }
  Function {updateeffects(int data)} {} {
    code {//
    int partnum = data >> 24;
    int effclass = (data >> 22) & 3;
    int parameter = (data >> 8) & 0x7f;

    if (effclass == 2)
    {
         // will be part effects
    }
    else if (effclass == 1)
    {
        ninseff = parameter & 0x3f;
        sysinsgroup->value(InsertionEffectsGrp);
        showInsEfxUI();
        inseffnocounter->value(ninseff + 1);
        inseffpart->value(partnum);
        if (partnum != 1) // off
        {
            insefftype->activate();
            inseffectui->activate();
        }
        else
        {
            insefftype->deactivate();
            inseffectui->deactivate();
        }
        insefftype->value(synth->insefx[ninseff]->geteffect());
        inseffectui->refresh(synth->insefx[ninseff], TOPLEVEL::section::insertEffects, ninseff);
    }
    else
    {
        nsyseff = parameter & 0x3f;
        sysinsgroup->value(SystemEffectsGrp);
        syseffnocounter->value(nsyseff + 1);
        sysefftype->value(synth->sysefx[nsyseff]->geteffect());
        syseffectui->refresh(synth->sysefx[nsyseff], TOPLEVEL::section::systemEffects, nsyseff);
        showSysEfxUI();
    }} {}
  }
  Function {updatecontrollers(int _npart)} {} {
    code {//
    if (npart == _npart)
        partui->ctlmidirefresh();} {}
  }
  Function {setMasterLabel(string name)} {} {
    code {//
    string prefix;
    string panel;
    if  (name.size())
    {
        prefix = synth->makeUniqueName(name);
        panel = synth->makeUniqueName("Mixer Panel - "+name);
    }
    else
    {
        prefix = synth->makeUniqueName("");
        prefix = prefix.substr(0, prefix.length() - 3);
        panel = prefix + " : Mixer Panel";
    }
    masterwindow->copy_label(prefix.c_str());
    panelwindow->copy_label(panel.c_str());
    masterwindow->changed();} {}
  }
  Function {do_load_scale(string fname)} {} {
    code {//
    send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedScale, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(fname));} {}
  }
  Function {do_load_instrument(string fname)} {} {
    code {//
    int npart = partui->npart;
    if ((npart /  NUM_MIDI_CHANNELS) == (panelgroup  /  NUM_MIDI_CHANNELS))
    {
        int displaypart = npart % NUM_MIDI_CHANNELS;
        panellistitem[displaypart]->partenabled->value(0);
        panellistitem[displaypart]->panellistitemgroup->deactivate();
    }
    partui->partGroupEnable->value(0);
    partui->partgroup->deactivate();
    send_data(TOPLEVEL::action::forceUpdate, MAIN::control::loadInstrumentByName, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, npart, UNUSED, UNUSED, textMsgBuffer.push(fname));} {}
  }
  Function {do_load_master(const char* file)} {} {
    code {//
    const char *fname;
    string lastname = synth->lastItemSeen(TOPLEVEL::XML::Patch);
    if (lastname == "")
        lastname = synth->getRuntime().userHome;
    if (NULL != file)
        fname = file;
    else
    {
        string exten = "({*" + EXTEN::patchset + "})";
        fname = fl_file_chooser("Load:", exten.c_str(), lastname.c_str(), 0);
        if (fname == NULL)
            return;
    }
    send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedPatchset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(fname));} {}
  }
  Function {do_save_master(const char* file = NULL)} {} {
    code {//
    const char *fname;
    string lastname = synth->getLastfileAdded(TOPLEVEL::XML::Patch);
    if (lastname == "")
        lastname = synth->getRuntime().userHome;
    bool result = false;
    if (file == NULL)
    {
        string exten = "({*" + EXTEN::patchset + "})";
        char *tmp = fl_file_chooser("Save:", exten.c_str(), lastname.c_str(), 0);
        if (tmp == NULL)
            return;
        tmp = fl_filename_setext(tmp, EXTEN::patchset.c_str());
        fname = tmp;
        result = isRegularFile(tmp);
        if (result)
        {
            result = false;
            if (fl_choice("The file exists. Overwrite it?", NULL, "No", "Yes") < 2)
                return;
        }
    }
    else
        fname = file;

    send_data(TOPLEVEL::action::lowPrio | TOPLEVEL::action::forceUpdate, MAIN::control::saveNamedPatchset, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(string(fname)));} {}
  }
  Function {refresh_master_ui(int type)} {} {
    code {//
    if (microtonalui) // not taking chances!
        delete microtonalui;
    partmax = synth->getRuntime().NumAvailableParts;
    maxparts->value(partmax);
    checkmaxparts();

    npartcounter->value((synth->getRuntime().currentPart) + 1);
    int nval = synth->getRuntime().currentPart;
    partNew(nval);
    activePart = nval;

    nsyseff = 0;
    syseffnocounter->value(nsyseff + 1);
    sysefftype->value(synth->sysefx[nsyseff]->geteffect());
    syseffectui->refresh(synth->sysefx[nsyseff], TOPLEVEL::section::systemEffects, nsyseff);

    ninseff = 0;
    inseffnocounter->value(nsyseff + 1);
    setInsEff(ninseff);

    sysinsgroup->value(SystemEffectsGrp);




    bool status;
    SysEffOn->value(fetchData(0, EFFECT::sysIns::effectEnable, TOPLEVEL::section::systemEffects, UNUSED, 0));
    if (SysEffOn->value())
        sysefftype->activate();
    else
        sysefftype->deactivate();
    int efftype = fetchData(0, EFFECT::sysIns::effectType, TOPLEVEL::section::systemEffects, UNUSED, 0);
    if (efftype > 0)
    {
        status = fetchData(0, 200, TOPLEVEL::section::systemEffects, efftype + EFFECT::type::none, ninseff);
        syseffectui->UpdatePresetColour(status, sysefftype->value());
    }
    efftype = fetchData(0,EFFECT::sysIns::effectType, TOPLEVEL::section::insertEffects, UNUSED, 0);
    if (efftype > 0)
    {
        status = fetchData(0, 200, TOPLEVEL::section::insertEffects, efftype + EFFECT::type::none, ninseff);
        inseffectui->UpdatePresetColour(status, insefftype->value());
    }




    showSysEfxUI();

    masterkeyshift->value(synth->Pkeyshift - 64);
    mastervolumedial->value(synth->Pvolume);
    globalfinedetune->value(synth->microtonal.Pglobalfinedetune);
    microtonalui = new MicrotonalUI(&synth->microtonal, synth);
    if (type & 0x80)
        setMasterLabel(textMsgBuffer.fetch((type >> 8) & UNUSED));
    updatesendwindow();
    updatepanel(type > 0);
    if (type != 5)
        vectorui->RefreshChans();
    bankui->Hide();
    /*if (synth->getRuntime().toConsole == false)
        Reports->deactivate();
    else
        Reports->activate();*/
    mastermono->value(0);
    mastermono->label("S");
    if (type == 0x14)
    {
        for (int i = 1; i < 6; ++i)
            configui->update_config(i);
    }} {}
  }
  Function {checkmaxparts()} {return_type bool
  } {
    code {//
    bool changed = false;
    if(panelgroup >= partmax)
    {
        panelgroup = 0;
        Panelgroups->value(0);
        Panelsmallgroups->value(0);
        changed = true;
    }
    npartcounter->range(1, partmax);
    if (npart >= partmax)
    {
        npartcounter->value(1);
        activePart = 0;
        changed = true;
    }
    return changed;} {}
  }
  Function {strategicRetreat(void)} {} {
    code {fl_alert("Bad things happened,\\nYoshimi strategically retreats.");} {}
  }
  Function {Log(string msg)} {} {
    code {yoshiLog->log(msg);} {}
  }
  Function {showSysEfxUI(void)} {private
  } {
    code {//
    inseffectui->hide();
    inseffectui->deactivate();
    inseffectuigroup->hide();
    inseffectuigroup->deactivate();

    syseffectui->activate();
    syseffectui->show();
    syseffectuigroup->activate();
    syseffectuigroup->show();} {}
  }
  Function {showInsEfxUI(void)} {private
  } {
    code {//
    syseffectui->hide();
    syseffectui->deactivate();
    syseffectuigroup->hide();
    syseffectuigroup->deactivate();

    inseffectui->activate();
    inseffectui->show();
    inseffectuigroup->activate();
    inseffectuigroup->show();} {}
  }
  Function {setinspartlist()} {} {
    code {//
    inseffpart->clear();
    inseffpart->add("Master Out");
    inseffpart->add("Off");
    int size = synth->getRuntime().NumAvailableParts;
    for (int i = 0; i < size; ++i)
    {
        string num = string("00") + asString(i + 1);
        inseffpart->add((string("Part ") + asString(i + 1)).c_str());
    }
    int current = synth->Pinsparts[ninseff];
    if (current >= size)
    {
        current = -1; // off is safe
        synth->Pinsparts[ninseff] = current;
    }
    inseffpart->value(current + 2);} {}
  }
  Function {getPresetsUi()} {return_type {PresetsUI *}
  } {
    code {//
    return presetsui;} {}
  }
  Function {resetPartsClip()} {} {
    code {//
    for (int i = 0; i < NUM_MIDI_CHANNELS; i++)
    {
        if(panellistitem[i] && panellistitem[i]->partVUMeter)
        {
            panellistitem[i]->partVUMeter->resetPart(true);
        }
    }} {}
  }
  Function {setInsEff(int effnum)} {} {
    code {//
    int ninseff = effnum;
    insefftype->value(synth->insefx[ninseff]->geteffect());
    inseffpart->value(synth->Pinsparts[ninseff] + 2);
    inseffectui->refresh(synth->insefx[ninseff], TOPLEVEL::section::insertEffects, ninseff);
    if (synth->Pinsparts[ninseff] != -1)
    {
        insefftype->activate();
        inseffectui->activate();
        inseffectuigroup->activate();
    }
    else
    {
        insefftype->deactivate();
        inseffectui->deactivate();
        inseffectuigroup->deactivate();
    }} {}
  }
  Function {setState(string filename)} {} {
    code {//
    send_data(TOPLEVEL::action::muteAndLoop | TOPLEVEL::action::forceUpdate, MAIN::control::loadNamedState, 0, TOPLEVEL::type::Integer, TOPLEVEL::section::main, UNUSED, UNUSED, UNUSED, textMsgBuffer.push(filename));} {}
  }
  Function {setPartWindowTitle(string prefix)} {return_type string
  } {
    code {//
    string extension = " - Part " + asString(partui->npart + 1) + " " + partui->part->Pname;
    if (partui->part->Pkitmode)
    {
        extension += ", Kit ";
        if (partui->lastkititem >= 0)
        {
            extension += to_string(partui->lastkititem + 1);
            if (partui->kitname > "")
                extension += (" - " + partui->kitname);
        }
    }
    return synth->makeUniqueName(prefix + extension);} {}
  }
  Function {setPartActive(int _npart, bool active)} {} {
    code {//
    if (_npart == npart)
    {
        partui->partGroupEnable->value(active);
        if (active)
        {
            partui->partgroupui->activate();
            partui->toSysEfx->activate();
        }
        else
        {
            partui->partgroupui->deactivate();
            partui->toSysEfx->deactivate();
        }
    }} {}
  }
  Function {setPartVolWidget(int _npart, float _value)} {} {
    code {//
    if (_npart == npart)
        partui->partvol->value(_value);} {}
  }
  Function {setPartPanWidget(int _npart, float _value)} {} {
    code {//
    if (_npart == npart)
        partui->partpan->value(_value);} {}
  }
  Function {setPanelPartVolWidget(int _npart, float _value)} {} {
    code {//
    panellistitem[_npart]->partvolume->value(_value);} {}
  }
  Function {setPanelPartPanWidget(int _npart, float _value)} {} {
    code {//
    panellistitem[_npart]->partpanning->value(_value);} {}
  }
  Function {setPartMidiWidget(int _npart, unsigned char _value)} {} {
    code {//
    if (_npart == npart)
        partui->midich->value(_value);
    partui->midich->textcolor(FL_BLACK);} {}
  }
  Function {setPanelPartMidiWidget(int _npart, unsigned char _value)} {} {
    code {//
    panellistitem[_npart]->partrcv->value(_value);
    panellistitem[_npart]->partrcv->textcolor(FL_BLACK);
    panellistitem[_npart]->partrcv->redraw();} {}
  }
  Function {setLogging(bool isConsole)} {} {
    code {//
    if (isConsole)
    {
        //Reports->activate();
        yoshiLog->Show();
    }
    else
    {
        //Reports->deactivate();
        yoshiLog->Hide();
    }} {}
  }
  Function {updateBankRootDirs()} {} {
    code {bankui->readbankcfg();} {}
  }
  Function {updatepaths(int type)} {} {
    code {//
    if (type == 0)
    {
        bankui->readbankcfg();
        bankui-> rescan_for_banks(false);
    }} {}
  }
  Function {ShowAlert(int num)} {} {
    code {fl_alert("%s", textMsgBuffer.fetch(num).c_str());} {}
  }
  Function {getSynth()} {return_type {SynthEngine *}
  } {
    code {return synth;} {}
  }
  Function {loadWindowData()} {} {
    code {//

    bool ok = false;
    bool tmpWindows;
    int masterX;
    int masterY;
    int masterO;

    windows = fopen(filename.c_str(), "r");
    if (windows == NULL)
        NewWindows = true;
    else
        NewWindows = false;
    ok = !NewWindows;
    tmpWindows = NewWindows;
    // we carry on anyway to set defaults
    ok = getData(ok,
                "master",
                 masterX,
                 masterY,
                 masterO);
    ok = getData(ok,
                "panel",
                 panelX,
                 panelY,
                 panelO);
    ok = getData(ok,
                "instruments",
                 instrumentsX,
                 instrumentsY,
                 instrumentsO);
    ok = getData(ok,
                "banks",
                 banksX,
                 banksY,
                 banksO);
    ok = getData(ok,
                "roots",
                 rootsX,
                 rootsY,
                 rootsO);
    ok = getData(ok,
                "presets",
                 presetsX,
                 presetsY,
                 presetsO);
    ok = getData(ok,
                "scales",
                 scalesX,
                 scalesY,
                 scalesO);
    if (NewWindows)
    {
         NewWindows = false;
         virkbdX = 400;
         virkbdY = 1;
         virkbdO = 1;
    }
    ok = getData(ok,
                "virtkeybd",
                 virkbdX,
                 virkbdY,
                 virkbdO);
    NewWindows = tmpWindows;
    ok = getData(ok,
                "settings",
                 settingsX,
                 settingsY,
                 settingsO);
    ok = getData(ok,
                "yoshiLog",
                 yoshiLogX,
                 yoshiLogY,
                 yoshiLogO);
    ok = getData(ok,
                "vectors",
                 vectorX,
                 vectorY,
                 vectorO);
    ok = getData(ok,
                "MIDIlearn",
                 mlearnX,
                 mlearnY,
                 mlearnO);
    ok = getData(ok,
                "controllers",
                 controllersX,
                 controllersY,
                 controllersO);
    ok = getData(ok,
                "midicontrols",
                 midictlX,
                 midictlY,
                 midictlO);
    ok = getData(ok,
                "instrumentedit",
                 inseditX,
                 inseditY,
                 inseditO);
    ok = getData(ok,
                "kitlist",
                 kitlistX,
                 kitlistY,
                 kitlistO);
    ok = getData(ok,
                "partFX",
                 partfxX,
                 partfxY,
                 partfxO);

    ok = getData(ok,
                "SUBnote",
                 subNoteX,
                 subNoteY,
                 subNoteO);
    ok = getData(ok,
                "PADnote",
                 padNoteX,
                 padNoteY,
                 padNoteO);
    ok = getData(ok,
                "ADDnote",
                 addNoteX,
                 addNoteY,
                 addNoteO);

   if (windows != NULL)
        fclose(windows);

    masterwindow->position(masterX, masterY);
    panelwindow->position(panelX, panelY);
    bankui->instrumentuiwindow->position(instrumentsX, instrumentsY);
    bankui->bankuiwindow->position(banksX, banksY);
    bankui->rootuiwindow->position(rootsX, rootsY);
    configui->presets->position(presetsX, presetsY);
    microtonalui->microtonaluiwindow->position(scalesX, scalesY);
    virkeyboard->virkeyboardwindow->position(virkbdX, virkbdY);
    configui->configwindow->position(settingsX, settingsY);
    yoshiLog->logConsole->position(yoshiLogX, yoshiLogY);
    vectorui->vectorwindow->position(vectorX, vectorY);
    midilearnui->midilearnwindow->position(mlearnX, mlearnY);
    partui->ctlwindow->position(controllersX, controllersY);
    partui->ctlmidi->position(midictlX, midictlY);
    partui->instrumenteditwindow->position(inseditX, inseditY);
    partui->instrumentkitlist->position(kitlistX, kitlistY);
    partui->partfx->position(partfxX, partfxY);} {}
  }
  Function {saveWindowData()} {} {
    code {//
    windows = fopen(filename.c_str(), "w");

    putData("master",
             masterwindow->x(),
             masterwindow->y(),
             masterwindow->visible());
    putData("panel",
             panelwindow->x(),
             panelwindow->y(),
             panelwindow->visible());
    putData("instruments",
             bankui->instrumentuiwindow->x(),
             bankui->instrumentuiwindow->y(),
             bankui->instrumentuiwindow->visible());
    putData("banks",
             bankui->bankuiwindow->x(),
             bankui->bankuiwindow->y(),
             bankui->bankuiwindow->visible());
    putData("roots",
             bankui->rootuiwindow->x(),
             bankui->rootuiwindow->y(),
             bankui->rootuiwindow->visible());
    putData("presets",
             configui->presets->x(),
             configui->presets->y(),
             configui->presets->visible());
    putData("scales",
             microtonalui->microtonaluiwindow->x(),
             microtonalui->microtonaluiwindow->y(),
             microtonalui->microtonaluiwindow->visible());
    putData("virtkeybd",
             virkeyboard->virkeyboardwindow->x(),
             virkeyboard->virkeyboardwindow->y(),
             virkeyboard->virkeyboardwindow->visible());
    putData("settings",
             configui->configwindow->x(),
             configui->configwindow->y(),
             configui->configwindow->visible());
    putData("yoshiLog",
             yoshiLog->logConsole->x(),
             yoshiLog->logConsole->y(),
             yoshiLog->logConsole->visible());
    putData("vectors",
             vectorui->vectorwindow->x(),
             vectorui->vectorwindow->y(),
             vectorui->vectorwindow->visible());
    putData("MIDIlearn",
             midilearnui->midilearnwindow->x(),
             midilearnui->midilearnwindow->y(),
             midilearnui->midilearnwindow->visible());

    if (partui->ctlwindow->x())
        putData("controllers",
                 partui->ctlwindow->x(),
                 partui->ctlwindow->y(),
                 partui->ctlwindow->visible());
    else // no window so store previous values
        putData("controllers",
                 controllersX,
                 controllersY,
                 controllersO);

    if (partui->ctlwindow->x())
        putData("midcontrols",
                 partui->ctlmidi->x(),
                 partui->ctlmidi->y(),
                 partui->ctlmidi->visible());
    else // no window so store previous values
        putData("controllers",
                 midictlX,
                 midictlY,
                 midictlO);

    if (partui->instrumenteditwindow->x())
        putData("instrumentedit",
                 partui->instrumenteditwindow->x(),
                 partui->instrumenteditwindow->y(),
                 partui->instrumenteditwindow->visible());
    else
        putData("instrumentedit",
                 inseditX,
                 inseditY,
                 inseditO);

    if (partui->instrumentkitlist->x())
        putData("kitlist",
                 partui->instrumentkitlist->x(),
                 partui->instrumentkitlist->y(),
                 partui->instrumentkitlist->visible());
    else
        putData("kitlist",
                 kitlistX,
                 kitlistY,
                 kitlistO);

    if(partui->partfx->x())
        putData("partFX",
                 partui->partfx->x(),
                 partui->partfx->y(),
                 partui->partfx->visible());
    else
        putData("partFX",
                 partfxX,
                 partfxY,
                 partfxO);

    putData("SUBnote",
             subNoteX,
             subNoteY,
             subNoteO);
    putData("PADnote",
             padNoteX,
             padNoteY,
             padNoteO);
    putData("ADDnote",
             addNoteX,
             addNoteY,
             addNoteO);

   fclose(windows);} {}
  }
  Function {getData(bool ok, string name, int& X, int& Y, int& O)} {return_type bool
  } {
    code {//
    if (NewWindows)
    {
        X = 1;
        Y = 1;
        O = 0;
    }
    if (!ok)
        return false;

    ok = (fgets(word, 20, windows) != NULL);
    if (ok)
        ok = strstr(word, name.c_str());
    if (true)
    {
        ok = false;
        if (fgets(word, 20, windows) != NULL)
            X = atoi(word);
        if (fgets(word, 20, windows) != NULL)
            Y = atoi(word);
        if (fgets(word, 20, windows) != NULL)
        {
            O = atoi(word);
            ok = true;
        }
    }
    return ok;} {}
  }
  Function {putData(string name, int X, int Y, int O)} {} {
    code {//
    string tosend = name + "\\n"
                  + asString(X)+ "\\n"
                  + asString(Y) + "\\n"
                  + asString(O) + "\\n";
    fputs(tosend.c_str(), windows);} {}
  }
  Function {checkBuffer(void)} {} {
    code {//
read_updates(synth);} {}
  }
  decl {ConfigUI *configui;} {public local
  }
  decl {ParametersUI *paramsui;} {public local
  }
  decl {VectorUI *vectorui;} {public local
  }
  decl {MidiLearnUI *midilearnui;} {public local
  }
  decl {BankUI *bankui;} {public local
  }
  decl {MicrotonalUI *microtonalui;} {public local
  }
  decl {VirKeyboard *virkeyboard;} {private local
  }
  decl {int ninseff;} {public local
  }
  decl {int npart;} {public local
  }
  decl {int activePart;} {public local
  }
  decl {int nsyseff;} {public local
  }
  decl {int partmax;} {
    comment {This is only public for vector control} public local
  }
  decl {SysEffSend *syseffsend[NUM_SYS_EFX][NUM_SYS_EFX];} {private local
  }
  decl {Panellistitem *panellistitem[NUM_MIDI_PARTS];} {public local
  }
  decl {ConsoleUI *yoshiLog;} {public local
  }
  decl {PresetsUI *presetsui;} {private local
  }
  decl {SynthEngine *synth;} {private local
  }
  decl {string panelwindowlabel} {private local
  }
  decl {int instance;} {private local
  }
  decl {int panelgroup;} {public local
  }
  decl {int CS_CC;} {private local
  }
  decl {char word [20];} {private local
  }
  decl {FILE *windows;} {private local
  }
  decl {string filename;} {private local
  }
  decl {int panelX;} {private local
  }
  decl {int panelY;} {private local
  }
  decl {int panelO;} {private local
  }
  decl {int instrumentsX;} {private local
  }
  decl {int instrumentsY;} {private local
  }
  decl {int instrumentsO;} {private local
  }
  decl {int banksX;} {private local
  }
  decl {int banksY;} {private local
  }
  decl {int banksO;} {private local
  }
  decl {int rootsX;} {private local
  }
  decl {int rootsY;} {private local
  }
  decl {int rootsO;} {private local
  }
  decl {int presetsX;} {private local
  }
  decl {int presetsY;} {private local
  }
  decl {int presetsO;} {private local
  }
  decl {int scalesX;} {private local
  }
  decl {int scalesY;} {private local
  }
  decl {int scalesO;} {private local
  }
  decl {int virkbdX;} {private local
  }
  decl {int virkbdY;} {private local
  }
  decl {int virkbdO;} {private local
  }
  decl {int settingsX;} {private local
  }
  decl {int settingsY;} {private local
  }
  decl {int settingsO;} {private local
  }
  decl {int yoshiLogX;} {private local
  }
  decl {int yoshiLogY;} {private local
  }
  decl {int yoshiLogO;} {private local
  }
  decl {int vectorX;} {public local
  }
  decl {int vectorY;} {public local
  }
  decl {int vectorO;} {public local
  }
  decl {int mlearnX;} {public local
  }
  decl {int mlearnY;} {public local
  }
  decl {int mlearnO;} {public local
  }
  decl {int controllersX;} {public local
  }
  decl {int controllersY;} {public local
  }
  decl {int controllersO;} {public local
  }
  decl {int midictlX;} {public local
  }
  decl {int midictlY;} {public local
  }
  decl {int midictlO;} {public local
  }
  decl {int inseditX;} {private local
  }
  decl {int inseditY;} {private local
  }
  decl {int inseditO;} {private local
  }
  decl {int kitlistX;} {private local
  }
  decl {int kitlistY;} {private local
  }
  decl {int kitlistO;} {private local
  }
  decl {int partfxX;} {private local
  }
  decl {int partfxY;} {private local
  }
  decl {int partfxO;} {private local
  }
  decl {int subNoteX;} {public local
  }
  decl {int subNoteY;} {public local
  }
  decl {int subNoteO;} {public local
  }
  decl {int padNoteX;} {public local
  }
  decl {int padNoteY;} {public local
  }
  decl {int padNoteO;} {public local
  }
  decl {int addNoteX;} {public local
  }
  decl {int addNoteY;} {public local
  }
  decl {int addNoteO;} {public local
  }
  decl {bool NewWindows;} {private local
  }
  decl {bool openedit;} {public local
  }
}
